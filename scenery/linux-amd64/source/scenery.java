/* autogenerated by Processing revision 1280 on 2022-03-18 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class scenery extends PApplet {

//test
Sun sun;
GrafOBJ shape1;
GrafOBJ shape2;
Terrain terrain;
Craft craft;
UFO ufo;
Star[] stars = new Star[500];
Sky sky;
float[] colors = new float[6];
int backgroundColor = color(0);
boolean recording = false;
float frames;





 public void setup(){
  /* size commented out by preprocessor */;
  colorMode(HSB, 360,100,100,100);
  setColors();
  //lights();
  frameRate(60);
  
  sun = new Sun();
  terrain = new Terrain();
  //craft = new Craft(0.3);
  ufo = new UFO(0.3f);

  Randomizer rnd = new Randomizer();
  shape1 = rnd.generate();
  shape2 = rnd.generate();
 

  for (int i = 0; i < stars.length; i++) {
    stars[i] = new Star();
  }
  
  sky = new Sky(colors[0]);
  
}

 public void draw(){
  translate(width/2,height/2);
  //calculating for terrain
  terrain.calculating();
  //calculating for sun
  sun.calculating();
  //craft.calculating();
  ufo.calculating();
    //preparing the screen
  //background(backgroundColor);
  sky.display();
  
  //calculating for shape

  //drawing sun
  sun.display();
  //drawing terrain
  terrain.display();
  //drawing shape
  
  //drawing engine
  //craft.display();
  
  ufo.display();

shape1.calculating();
shape1.display();

shape2.calculating();
shape2.display();
  

  
  
  //drawing stars
  for (int i = 0; i < stars.length; i++) {
    stars[i].update();
    stars[i].show();
  } 
  if (recording){
     saveFrame("render/output_####.png");
  
     frames++;
     println(frames/60 + "seconds recorded");
  }
}

 public void mouseClicked(){

  recording = true;

}
class Circle implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
  //variables for movement
  boolean shapeMovementDirection =true;
  int shapeMovementCount;
  int shapeMovementAmplitude = 60;
  float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
  float shapeMovementAcceleration = 0.1f;
  //variables for shrinking
  boolean shapeShrinkingDirection =true;
  int shapeShrinkingCount;
  int shapeShrinkingAmplitude = 200;
  float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
  float shapeShrinkingAcceleration = 0.1f;

  float shapeSize =10;
  int shapeColor = color(188, 70,165);
  float xRotation;
  float yRotation;
  float zRotation;
  float xRotationSpeed = 0;
  float yRotationSpeed = 0.0008f; 
  float zRotationSpeed = 0.0002f;

//сюда передаём значения особых переменных
Circle() {

}

//общие переменные
 public void setuping(float xShape, float yShape, float zShape,int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude, float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
  this.xShape = xShape;
  this.yShape = yShape;
  this.zShape = zShape;
  this.shapeMovementAmplitude = shapeMovementAmplitude;
  this.shapeMovementAcceleration = shapeMovementAcceleration;
  this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
  this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
  this.shapeSize = shapeSize;
  this.shapeColor = shapeColor;
  this.xRotation = xRotation;
  this.yRotation = yRotation;
  this.zRotation = zRotation;
  this.xRotationSpeed =  xRotationSpeed;
  this.yRotationSpeed =  yRotationSpeed;
  this.zRotationSpeed =  zRotationSpeed;

}


 public void calculating() {
  //calculating movement behaviour
if (shapeMovementDirection==true){
    shapeMovementVelocity+=shapeMovementAcceleration;
    shapeMovementCount++;
  }
  else{
    shapeMovementVelocity-=shapeMovementAcceleration;
    shapeMovementCount--;
  }
if (shapeMovementCount==shapeMovementAmplitude){
    
  shapeMovementDirection =false;
}
if (shapeMovementCount==-shapeMovementAmplitude){
    
  shapeMovementDirection =true;
}

//calculating shrinking behaviour
if (shapeShrinkingDirection==true){
    shapeShrinkingVelocity+=shapeShrinkingAcceleration;
    shapeShrinkingCount++;
  }
  else{
    shapeShrinkingVelocity-=shapeShrinkingAcceleration;
    shapeShrinkingCount--;
  }
if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
  shapeShrinkingDirection =false;
}
if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
  shapeShrinkingDirection =true;
}

//changing angle of a shape
xRotation+=xRotationSpeed;
yRotation+=yRotationSpeed;
zRotation+=zRotationSpeed;

}

 public void display() {

stroke(shapeColor);
noFill();
strokeWeight(4);

pushMatrix();
translate(xShape ,yShape, zShape);
rotateX(xRotation);
rotateY(yRotation);
rotateZ(zRotation);


circle(shapeMovementVelocity,shapeMovementVelocity, 2*(shapeSize+shapeShrinkingVelocity));
popMatrix();
}
}
static class Generator {

 
  Generator() {
    
  }
  
   public static GrafOBJ generate(GrafOBJ obj,float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude, float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
    obj.setuping(xShape, yShape, zShape,shapeMovementAmplitude, shapeMovementAcceleration, shapeShrinkingAmplitude, shapeShrinkingAcceleration, shapeSize, shapeColor, xRotation, yRotation, zRotation, xRotationSpeed, yRotationSpeed, zRotationSpeed);
    return obj;
  }
  

}

class Randomizer {
    int randShape = -1;
    int side = -1;
    int col = 4;
  
     public GrafOBJ generate() {
    
     if(randShape == -1) randShape = PApplet.parseInt(random(0,30));
     else {
       side = 1;
       col = 5;
       int rs = randShape;
       while(rs == randShape) {
         randShape = PApplet.parseInt(random(0,30));
       }
     
     }
    
   float acc = random(0.2f, 0.5f);
     switch(randShape){
    case 0:
      return Generator.generate(new Cube(), side*300, -150, 10, 60, acc, 200, 0.1f, 50, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
      
    case 1:
      return Generator.generate(new StarShape(), side*300, -150, 10, 60, acc, 200, 0.1f, 80, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
      
    case 2:
      return Generator.generate(new Merkaba(), side*300, -150, 10, 60, acc, 200, 0.1f, 65, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
    
    case 3:
      return Generator.generate(new Octahedron(), side*300, -150, 10, 60, acc, 200, 0.1f, 65, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
     
    case 4:
      return Generator.generate(new Heart(), side*300, -150, 10, 60, acc, 200, 0.1f, 50, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
     
    case 5:
      return Generator.generate(new Tetrahedron(), side*300, -150, 10, 60, acc, 200, 0.1f, 60, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
      
    case 6:
      return Generator.generate(new SuperShape(), side*300, -150, 10, 60, acc, 200, 0.1f, 70, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
      
    case 7:
      return Generator.generate(new Sphere(), side*300, -150, 10, 60, acc, 200, 0.1f, 50, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
      
    case 8:
      return Generator.generate(new StrangeHedron1(), side*300, -150, 10, 60, acc, 200, 0.1f, 50, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
    
    case 9:
      return Generator.generate(new StrangeHedron2(), side*300, -150, 10, 60, acc, 200, 0.1f, 50, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
      
    case 10:
      return Generator.generate(new StrangeHedron3(), side*300, -150, 10, 60, acc, 200, 0.1f, 50, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
    case 11:
      return Generator.generate(new Square(), side*300, -150, 10, 60, acc, 200, 0.1f, 50, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
    case 12:
      return Generator.generate(new Circle(), side*300, -150, 10, 60, acc, 200, 0.1f, 50, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
    case 13:
      return Generator.generate(new Triangle(), side*300, -150, 10, 60, acc, 200, 0.1f, 50, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
    case 14:
      return Generator.generate(new Veneric(), side*300, -150, 10, 60, acc, 200, 0.1f, 40, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
    case 15:
      return Generator.generate(new Mars(), side*300, -150, 10, 60, acc, 200, 0.1f, 40, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
    case 16:
      return Generator.generate(new Trans(), side*300, -150, 10, 60, acc, 200, 0.1f, 40, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
    case 17:
      return Generator.generate(new Smile(), side*300, -150, 10, 60, acc, 200, 0.1f, 55, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
    case 18:
      return Generator.generate(new HavaNagila(), side*300, -150, 10, 60, acc, 200, 0.1f, 55, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
    case 19:
      return Generator.generate(new SuperShape3D1(), side*300, -150, 10, 60, acc, 200, 0.1f, 80, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
    case 20:
      return Generator.generate(new SuperShape3D2(), side*300, -150, 10, 60, acc, 200, 0.1f, 80, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
    case 21:
      return Generator.generate(new SuperShape3D3(), side*300, -150, 10, 60, acc, 200, 0.1f, 80, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
    case 22:
      return Generator.generate(new SerpTriangle(), side*300, -150, 10, 60, acc, 200, 0.1f, 230, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
    case 23:
      return Generator.generate(new Sponge(), side*300, -150, 10, 60, acc, 200, 0.1f, 90, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
    case 24: 
      return Generator.generate(new WindRose(), side*300, -150, 10, 60, acc, 200, 0.1f, 90, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
    case 25:
      return Generator.generate(new Pacific(), side*300, -150, 10, 60, acc, 200, 0.1f, 60, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
    case 26:
      return Generator.generate(new MaurerRose(), side*300, -150, 10, 60, acc, 200, 0.1f, 70, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
    case 27:
      return Generator.generate(new LGBT(), side*300, -170, 10, 60, acc, 200, 0.1f, 120, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
    case 28:
      return Generator.generate(new SuperShape2(), side*300, -150, 10, 60, acc, 200, 0.1f, 70, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
    case 29:
      return Generator.generate(new SuperShape3(), side*300, -150, 10, 60, acc, 200, 0.1f, 65, color(colors[col],100,100), 0, 0, 0, 0, 0.008f, 0.002f);
   
    default:
      return null;
     }
      
    }


}
interface GrafOBJ {

    void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude,float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed);
    
    void calculating();
    
    void display();


}
class HavaNagila implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
  //variables for movement
  boolean shapeMovementDirection =true;
  int shapeMovementCount;
  int shapeMovementAmplitude = 60;
  float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
  float shapeMovementAcceleration = 0.1f;
  //variables for shrinking
  boolean shapeShrinkingDirection =true;
  int shapeShrinkingCount;
  int shapeShrinkingAmplitude = 200;
  float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
  float shapeShrinkingAcceleration = 0.1f;

  float shapeSize =100;
  int shapeColor = color(200, 100,58);
  float xRotation;
  float yRotation;
  float zRotation;
  float xRotationSpeed = 0;
  float yRotationSpeed = 0.0008f; 
  float zRotationSpeed = 0.0002f;


  HavaNagila(){
   
   
  }
  
   public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude, float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
    this.xShape = xShape;
    this.yShape = yShape;
    this.zShape = zShape;
    this.shapeMovementAmplitude = shapeMovementAmplitude;
    this.shapeMovementAcceleration = shapeMovementAcceleration;
    this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
    this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
    this.shapeSize = shapeSize;
    this.shapeColor = shapeColor;
    this.xRotation = xRotation;
    this.yRotation = yRotation;
    this.zRotation = zRotation;
    this.xRotationSpeed =  xRotationSpeed;
    this.yRotationSpeed =  yRotationSpeed;
    this.zRotationSpeed =  zRotationSpeed;

}
  
   public void calculating() {
    //calculating movement behaviour
    if (shapeMovementDirection==true){
      shapeMovementVelocity+=shapeMovementAcceleration;
      shapeMovementCount++;
    }
    else{
      shapeMovementVelocity-=shapeMovementAcceleration;
      shapeMovementCount--;
    }
    if (shapeMovementCount==shapeMovementAmplitude){
    
      shapeMovementDirection =false;
    }
    if (shapeMovementCount==-shapeMovementAmplitude){
    
      shapeMovementDirection =true;
    }


    //calculating shrinking behaviour
    if (shapeShrinkingDirection==true){
      shapeShrinkingVelocity+=shapeShrinkingAcceleration;
      shapeShrinkingCount++;
    }
    else{
      shapeShrinkingVelocity-=shapeShrinkingAcceleration;
      shapeShrinkingCount--;
    }
    if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =false;
    }
    if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =true;
    }

    //changing angle of a shape
    xRotation+=xRotationSpeed;
    yRotation+=yRotationSpeed;
    zRotation+=zRotationSpeed;
  }
   public void display(){
  strokeWeight(4);
  stroke(shapeColor);
   pushMatrix();
    translate(xShape+shapeMovementVelocity,yShape, zShape);
    rotateX(xRotation);
    rotateY(yRotation);
    rotateZ(zRotation);
    beginShape(TRIANGLES);

    vertex(shapeSize, -shapeSize/sqrt(3));
    vertex(-shapeSize, -shapeSize/sqrt(3));
    vertex(0, 2*shapeSize/sqrt(3));
    
    endShape(CLOSE);
    rotateZ(PI);
    rotateY(PI);
    beginShape(TRIANGLES);
    
    vertex(shapeSize, -shapeSize/sqrt(3));
    vertex(-shapeSize, -shapeSize/sqrt(3));
    vertex(0, 2*shapeSize/sqrt(3));
    
    endShape(CLOSE);
    popMatrix();
  }
}
class LGBT implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
  //variables for movement
  boolean shapeMovementDirection =true;
  int shapeMovementCount;
  int shapeMovementAmplitude = 60;
  float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
  float shapeMovementAcceleration = 0.1f;
  //variables for shrinking
  boolean shapeShrinkingDirection =true;
  int shapeShrinkingCount;
  int shapeShrinkingAmplitude = 200;
  float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
  float shapeShrinkingAcceleration = 0.1f;

  float shapeSize =100;
  int shapeColor = color(200, 100,58);
  float xRotation;
  float yRotation;
  float zRotation;
  float xRotationSpeed = 0;
  float yRotationSpeed = 0.0008f; 
  float zRotationSpeed = 0.0002f;
  float red = random(340, 360);
  float orange = random(15, 41);
  float yellow = random(46, 70);
  float green = random(71, 148);
  float blue = random(202, 253);
  float purple = random(260, 288);
  float[] massiv = {red, orange, yellow, green, blue, purple};


  LGBT(){
   
   
  }
  
   public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude, float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
    this.xShape = xShape;
    this.yShape = yShape;
    this.zShape = zShape;
    this.shapeMovementAmplitude = shapeMovementAmplitude;
    this.shapeMovementAcceleration = shapeMovementAcceleration;
    this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
    this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
    this.shapeSize = shapeSize;
    this.shapeColor = shapeColor;
    this.xRotation = xRotation;
    this.yRotation = yRotation;
    this.zRotation = zRotation;
    this.xRotationSpeed =  xRotationSpeed;
    this.yRotationSpeed =  yRotationSpeed;
    this.zRotationSpeed =  zRotationSpeed;

}
  
   public void calculating() {
    //calculating movement behaviour
    if (shapeMovementDirection==true){
      shapeMovementVelocity+=shapeMovementAcceleration;
      shapeMovementCount++;
    }
    else{
      shapeMovementVelocity-=shapeMovementAcceleration;
      shapeMovementCount--;
    }
    if (shapeMovementCount==shapeMovementAmplitude){
    
      shapeMovementDirection =false;
    }
    if (shapeMovementCount==-shapeMovementAmplitude){
    
      shapeMovementDirection =true;
    }


    //calculating shrinking behaviour
    if (shapeShrinkingDirection==true){
      shapeShrinkingVelocity+=shapeShrinkingAcceleration;
      shapeShrinkingCount++;
    }
    else{
      shapeShrinkingVelocity-=shapeShrinkingAcceleration;
      shapeShrinkingCount--;
    }
    if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =false;
    }
    if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =true;
    }

    //changing angle of a shape
    xRotation+=xRotationSpeed;
    yRotation+=yRotationSpeed;
    zRotation+=zRotationSpeed;
  }
   public void display(){
  strokeWeight(10);
  stroke(shapeColor);
   pushMatrix();
    translate(xShape+shapeMovementVelocity,yShape, zShape);
    rotateX(xRotation);
    rotateY(yRotation);
    rotateZ(zRotation);
    for (int j = 1; j<7; j++){
      beginShape();
      stroke(massiv[j-1], 100, 100, 100);
      for (float i=-shapeSize; i<shapeSize; i+=0.1f){
      //fill(massiv[j-1], 100, 100, 100);
      float x = i/2;
      float y = 0.133f*shapeSize*sin(0.025f*i);
      //fill(massiv[j-1], 100, 100, 100);
      vertex(x,y+j*9.5f);
      //noFill();
      }
      endShape();
    
  }
  popMatrix();
  strokeWeight(1);
}
}
class Mars implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
  //variables for movement
  boolean shapeMovementDirection =true;
  int shapeMovementCount;
  int shapeMovementAmplitude = 60;
  float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
  float shapeMovementAcceleration = 0.1f;
  //variables for shrinking
  boolean shapeShrinkingDirection =true;
  int shapeShrinkingCount;
  int shapeShrinkingAmplitude = 200;
  float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
  float shapeShrinkingAcceleration = 0.1f;

  float shapeSize =100;
  int shapeColor = color(200, 100,58);
  float xRotation;
  float yRotation;
  float zRotation;
  float xRotationSpeed = 0;
  float yRotationSpeed = 0.0008f; 
  float zRotationSpeed = 0.0002f;


  Mars(){
   
   
  }
  
   public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude, float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
    this.xShape = xShape;
    this.yShape = yShape;
    this.zShape = zShape;
    this.shapeMovementAmplitude = shapeMovementAmplitude;
    this.shapeMovementAcceleration = shapeMovementAcceleration;
    this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
    this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
    this.shapeSize = shapeSize;
    this.shapeColor = shapeColor;
    this.xRotation = xRotation;
    this.yRotation = yRotation;
    this.zRotation = zRotation;
    this.xRotationSpeed =  xRotationSpeed;
    this.yRotationSpeed =  yRotationSpeed;
    this.zRotationSpeed =  zRotationSpeed;

}
  
   public void calculating() {
    //calculating movement behaviour
    if (shapeMovementDirection==true){
      shapeMovementVelocity+=shapeMovementAcceleration;
      shapeMovementCount++;
    }
    else{
      shapeMovementVelocity-=shapeMovementAcceleration;
      shapeMovementCount--;
    }
    if (shapeMovementCount==shapeMovementAmplitude){
    
      shapeMovementDirection =false;
    }
    if (shapeMovementCount==-shapeMovementAmplitude){
    
      shapeMovementDirection =true;
    }


    //calculating shrinking behaviour
    if (shapeShrinkingDirection==true){
      shapeShrinkingVelocity+=shapeShrinkingAcceleration;
      shapeShrinkingCount++;
    }
    else{
      shapeShrinkingVelocity-=shapeShrinkingAcceleration;
      shapeShrinkingCount--;
    }
    if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =false;
    }
    if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =true;
    }

    //changing angle of a shape
    xRotation+=xRotationSpeed;
    yRotation+=yRotationSpeed;
    zRotation+=zRotationSpeed;
  }
   public void display(){
  strokeWeight(4);
  stroke(shapeColor);
   pushMatrix();
    translate(xShape+shapeMovementVelocity,yShape, zShape);
    rotateX(xRotation);
    rotateY(yRotation);
    rotateZ(zRotation);
    beginShape();
    for (float angle=0; angle<TWO_PI; angle+=0.01f){
      float x = shapeSize *cos(angle);
      float y = shapeSize*sin(angle);
      vertex(x,y);
    }
    
    endShape();
    line(shapeSize *cos(HALF_PI), shapeSize*sin(HALF_PI), shapeSize *cos(HALF_PI), shapeSize*sin(HALF_PI)+shapeSize*1.4f);
line(shapeSize *cos(HALF_PI), shapeSize*sin(HALF_PI)+shapeSize*1.4f,shapeSize *cos(HALF_PI)-shapeSize/2, shapeSize*sin(HALF_PI)+shapeSize*1.4f-shapeSize/2 );
    line(shapeSize *cos(HALF_PI), shapeSize*sin(HALF_PI)+shapeSize*1.4f,shapeSize *cos(HALF_PI)+shapeSize/2, shapeSize*sin(HALF_PI)+shapeSize*1.4f-shapeSize/2 );

    popMatrix();
  }
}
class MaurerRose implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
  //variables for movement
  boolean shapeMovementDirection =true;
  int shapeMovementCount;
  int shapeMovementAmplitude = 60;
  float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
  float shapeMovementAcceleration = 0.1f;
  //variables for shrinking
  boolean shapeShrinkingDirection =true;
  int shapeShrinkingCount;
  int shapeShrinkingAmplitude = 200;
  float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
  float shapeShrinkingAcceleration = 0.1f;

  float shapeSize =100;
  int shapeColor = color(200, 100,58);
  float xRotation;
  float yRotation;
  float zRotation;
  float xRotationSpeed = 0;
  float yRotationSpeed = 0.0008f; 
  float zRotationSpeed = 0.0002f;
  float n = random(1,10);
  float d = random(10,100);


  MaurerRose(){
   
   
  }
  
   public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude, float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
    this.xShape = xShape;
    this.yShape = yShape;
    this.zShape = zShape;
    this.shapeMovementAmplitude = shapeMovementAmplitude;
    this.shapeMovementAcceleration = shapeMovementAcceleration;
    this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
    this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
    this.shapeSize = shapeSize;
    this.shapeColor = shapeColor;
    this.xRotation = xRotation;
    this.yRotation = yRotation;
    this.zRotation = zRotation;
    this.xRotationSpeed =  xRotationSpeed;
    this.yRotationSpeed =  yRotationSpeed;
    this.zRotationSpeed =  zRotationSpeed;

}
  
   public void calculating() {
    //calculating movement behaviour
    if (shapeMovementDirection==true){
      shapeMovementVelocity+=shapeMovementAcceleration;
      shapeMovementCount++;
    }
    else{
      shapeMovementVelocity-=shapeMovementAcceleration;
      shapeMovementCount--;
    }
    if (shapeMovementCount==shapeMovementAmplitude){
    
      shapeMovementDirection =false;
    }
    if (shapeMovementCount==-shapeMovementAmplitude){
    
      shapeMovementDirection =true;
    }


    //calculating shrinking behaviour
    if (shapeShrinkingDirection==true){
      shapeShrinkingVelocity+=shapeShrinkingAcceleration;
      shapeShrinkingCount++;
    }
    else{
      shapeShrinkingVelocity-=shapeShrinkingAcceleration;
      shapeShrinkingCount--;
    }
    if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =false;
    }
    if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =true;
    }

    //changing angle of a shape
    xRotation+=xRotationSpeed;
    yRotation+=yRotationSpeed;
    zRotation+=zRotationSpeed;
  }
   public void display(){
  strokeWeight(1);
  stroke(shapeColor);
   pushMatrix();
    translate(xShape+shapeMovementVelocity,yShape, zShape);
    rotateX(xRotation);
    rotateY(yRotation);
    rotateZ(zRotation);
    beginShape();
    for (int angle = 0; angle<360; angle++){
      float k = angle*d*PI/180;
      float r = shapeSize*sin(n*k);
      float x  = r * cos(k);
      float y  = r * sin(k);
      
      curveVertex(x,y);
  
    }
    endShape();
   popMatrix();
  }
}
class Merkaba implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
  //variables for movement
  boolean shapeMovementDirection =true;
  int shapeMovementCount;
  int shapeMovementAmplitude = 60;
  float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
  float shapeMovementAcceleration = 0.1f;
  //variables for shrinking
  boolean shapeShrinkingDirection =true;
  int shapeShrinkingCount;
  int shapeShrinkingAmplitude = 200;
  float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
  float shapeShrinkingAcceleration = 0.1f;

  float shapeSize =100;
  int shapeColor = color(200, 100,58);
  float xRotation;
  float yRotation;
  float zRotation;
  float xRotationSpeed = 0;
  float yRotationSpeed = 0.0008f; 
  float zRotationSpeed = 0.0002f;

  Merkaba() {
   
   
  }
  
    public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude, float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
    this.xShape = xShape;
    this.yShape = yShape;
    this.zShape = zShape;
    this.shapeMovementAmplitude = shapeMovementAmplitude;
    this.shapeMovementAcceleration = shapeMovementAcceleration;
    this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
    this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
    this.shapeSize = shapeSize;
    this.shapeColor = shapeColor;
    this.xRotation = xRotation;
    this.yRotation = yRotation;
    this.zRotation = zRotation;
    this.xRotationSpeed =  xRotationSpeed;
    this.yRotationSpeed =  yRotationSpeed;
    this.zRotationSpeed =  zRotationSpeed;

}
  
   public void calculating() {
    //calculating movement behaviour
    if (shapeMovementDirection==true){
      shapeMovementVelocity+=shapeMovementAcceleration;
      shapeMovementCount++;
    }
    else{
      shapeMovementVelocity-=shapeMovementAcceleration;
      shapeMovementCount--;
    }
    if (shapeMovementCount==shapeMovementAmplitude){
    
      shapeMovementDirection =false;
    }
    if (shapeMovementCount==-shapeMovementAmplitude){
    
      shapeMovementDirection =true;
    }


    //calculating shrinking behaviour
    if (shapeShrinkingDirection==true){
      shapeShrinkingVelocity+=shapeShrinkingAcceleration;
      shapeShrinkingCount++;
    }
    else{
      shapeShrinkingVelocity-=shapeShrinkingAcceleration;
      shapeShrinkingCount--;
    }
    if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =false;
    }
    if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =true;
    }

    //changing angle of a shape
    xRotation+=xRotationSpeed;
    yRotation+=yRotationSpeed;
    zRotation+=zRotationSpeed;
  }
  
    public void display(){
    stroke((shapeColor+120)%360,100,100);
    strokeWeight(4);
    
    pushMatrix();
    
    translate(xShape+shapeMovementVelocity,yShape, zShape);
    rotateX(xRotation);
    rotateY(yRotation);
    rotateZ(zRotation);
    fill(color(colors[5],100,100));
    
    
    
beginShape(TRIANGLES);

    vertex(shapeSize, -shapeSize/sqrt(3),-shapeSize/sqrt(6));
    vertex(-shapeSize, -shapeSize/sqrt(3),-shapeSize/sqrt(6));
    vertex(0, 2*shapeSize/sqrt(3), -shapeSize/sqrt(6));

    vertex(shapeSize, -shapeSize/sqrt(3),-shapeSize/sqrt(6));
    vertex(0, 2*shapeSize/sqrt(3), -shapeSize/sqrt(6));
    vertex(0,0,3*shapeSize/sqrt(6));
    vertex(shapeSize, -shapeSize/sqrt(3),-shapeSize/sqrt(6));

    vertex(0,0,3*shapeSize/sqrt(6));
    vertex(-shapeSize, -shapeSize/sqrt(3),-shapeSize/sqrt(6));
    vertex(0,0,3*shapeSize/sqrt(6));
    
    vertex(0, 2*shapeSize/sqrt(3), -shapeSize/sqrt(6));
    vertex(-shapeSize, -shapeSize/sqrt(3),-shapeSize/sqrt(6));
    vertex(0,0,3*shapeSize/sqrt(6));

    endShape(CLOSE);
    rotateZ(PI);
    rotateY(PI);
   beginShape(TRIANGLES);

    vertex(shapeSize, -shapeSize/sqrt(3),-shapeSize/sqrt(6));
    vertex(-shapeSize, -shapeSize/sqrt(3),-shapeSize/sqrt(6));
    vertex(0, 2*shapeSize/sqrt(3), -shapeSize/sqrt(6));

    vertex(shapeSize, -shapeSize/sqrt(3),-shapeSize/sqrt(6));
    vertex(0, 2*shapeSize/sqrt(3), -shapeSize/sqrt(6));
    vertex(0,0,3*shapeSize/sqrt(6));
    vertex(shapeSize, -shapeSize/sqrt(3),-shapeSize/sqrt(6));

    vertex(0,0,3*shapeSize/sqrt(6));
    vertex(-shapeSize, -shapeSize/sqrt(3),-shapeSize/sqrt(6));
    vertex(0,0,3*shapeSize/sqrt(6));
    
    vertex(0, 2*shapeSize/sqrt(3), -shapeSize/sqrt(6));
    vertex(-shapeSize, -shapeSize/sqrt(3),-shapeSize/sqrt(6));
    vertex(0,0,3*shapeSize/sqrt(6));



    endShape(CLOSE);
popMatrix();
    noFill();
   }
}
class Pacific implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
  //variables for movement
  boolean shapeMovementDirection =true;
  int shapeMovementCount;
  int shapeMovementAmplitude = 60;
  float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
  float shapeMovementAcceleration = 0.1f;
  //variables for shrinking
  boolean shapeShrinkingDirection =true;
  int shapeShrinkingCount;
  int shapeShrinkingAmplitude = 200;
  float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
  float shapeShrinkingAcceleration = 0.1f;

  float shapeSize =100;
  int shapeColor = color(200, 100,58);
  float xRotation;
  float yRotation;
  float zRotation;
  float xRotationSpeed = 0;
  float yRotationSpeed = 0.0008f; 
  float zRotationSpeed = 0.0002f;


  Pacific() {
   
   
  }
  
   public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude, float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
    this.xShape = xShape;
    this.yShape = yShape;
    this.zShape = zShape;
    this.shapeMovementAmplitude = shapeMovementAmplitude;
    this.shapeMovementAcceleration = shapeMovementAcceleration;
    this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
    this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
    this.shapeSize = shapeSize;
    this.shapeColor = shapeColor;
    this.xRotation = xRotation;
    this.yRotation = yRotation;
    this.zRotation = zRotation;
    this.xRotationSpeed =  xRotationSpeed;
    this.yRotationSpeed =  yRotationSpeed;
    this.zRotationSpeed =  zRotationSpeed;

}
  
   public void calculating() {
    //calculating movement behaviour
    if (shapeMovementDirection==true){
      shapeMovementVelocity+=shapeMovementAcceleration;
      shapeMovementCount++;
    }
    else{
      shapeMovementVelocity-=shapeMovementAcceleration;
      shapeMovementCount--;
    }
    if (shapeMovementCount==shapeMovementAmplitude){
    
      shapeMovementDirection =false;
    }
    if (shapeMovementCount==-shapeMovementAmplitude){
    
      shapeMovementDirection =true;
    }


    //calculating shrinking behaviour
    if (shapeShrinkingDirection==true){
      shapeShrinkingVelocity+=shapeShrinkingAcceleration;
      shapeShrinkingCount++;
    }
    else{
      shapeShrinkingVelocity-=shapeShrinkingAcceleration;
      shapeShrinkingCount--;
    }
    if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =false;
    }
    if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =true;
    }

    //changing angle of a shape
    xRotation+=xRotationSpeed;
    yRotation+=yRotationSpeed;
    zRotation+=zRotationSpeed;
  }
  
   public void display(){
    stroke(shapeColor);
    strokeWeight(4);
    
    pushMatrix();
    translate(xShape+shapeMovementVelocity,yShape, zShape);
    rotateX(xRotation);
    rotateY(yRotation);
    rotateZ(zRotation);


    //actually drawing the shape
    beginShape();
      for (float a =0; a<TWO_PI; a+=0.01f){
      float x = shapeSize*cos(a);
      float y =shapeSize*sin(a);
      vertex(x,y);
      }
      endShape();
      line(0,-shapeSize,0,shapeSize);
      line(0, 0, shapeSize*sin(PI+PI/4), -shapeSize*cos(PI+PI/4));
      line(0, 0, -shapeSize*sin(PI+PI/4), -shapeSize*cos(PI+PI/4));
    popMatrix();
  }
}
class SerpTriangle implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
  //variables for movement
  boolean shapeMovementDirection =true;
  int shapeMovementCount;
  int shapeMovementAmplitude = 60;
  float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
  float shapeMovementAcceleration = 0.1f;
  //variables for shrinking
  boolean shapeShrinkingDirection =true;
  int shapeShrinkingCount;
  int shapeShrinkingAmplitude = 200;
  float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
  float shapeShrinkingAcceleration = 0.1f;

  float shapeSize=300;
  int shapeColor = color(200, 100,58);
  float xRotation;
  float yRotation;
  float zRotation;
  float xRotationSpeed = 0;
  float yRotationSpeed = 0.0008f; 
  float zRotationSpeed = 0.0002f;
     int depth   = 6;  // recursion depth

 

  SerpTriangle() {
   
   
  }
  
   public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude, float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
    this.xShape = xShape;
    this.yShape = yShape;
    this.zShape = zShape;
    this.shapeMovementAmplitude = shapeMovementAmplitude;
    this.shapeMovementAcceleration = shapeMovementAcceleration;
    this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
    this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
    this.shapeSize = shapeSize;
    this.shapeColor = shapeColor;
    this.xRotation = xRotation;
    this.yRotation = yRotation;
    this.zRotation = zRotation;
    this.xRotationSpeed =  xRotationSpeed;
    this.yRotationSpeed =  yRotationSpeed;
    this.zRotationSpeed =  zRotationSpeed;

}
  
   public void calculating() {
    //calculating movement behaviour
    if (shapeMovementDirection==true){
      shapeMovementVelocity+=shapeMovementAcceleration;
      shapeMovementCount++;
    }
    else{
      shapeMovementVelocity-=shapeMovementAcceleration;
      shapeMovementCount--;
    }
    if (shapeMovementCount==shapeMovementAmplitude){
    
      shapeMovementDirection =false;
    }
    if (shapeMovementCount==-shapeMovementAmplitude){
    
      shapeMovementDirection =true;
    }


    //calculating shrinking behaviour
    if (shapeShrinkingDirection==true){
      shapeShrinkingVelocity+=shapeShrinkingAcceleration;
      shapeShrinkingCount++;
    }
    else{
      shapeShrinkingVelocity-=shapeShrinkingAcceleration;
      shapeShrinkingCount--;
    }
    if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =false;
    }
    if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =true;
    }

    //changing angle of a shape
    xRotation+=xRotationSpeed;
    yRotation+=yRotationSpeed;
    zRotation+=zRotationSpeed;
  }
  
   public void display(){
    stroke(shapeColor);
    strokeWeight(1);
    
    pushMatrix();
    translate(xShape+shapeMovementVelocity,yShape, zShape);
    rotateX(xRotation);
    rotateY(yRotation);
    rotateZ(zRotation);

    PVector startPoint = new PVector(150.0f/600*shapeSize, 183.7f/600*shapeSize, 173.2f/600*shapeSize);

    //actually drawing the shape
    sierpinski(startPoint, depth);
    popMatrix();
  }
   public void sierpinski(PVector currentPoint, int currentDepth)
{
 
// 3D Sierpinski tetrahedron vertices
PVector [] coord = {
  new PVector(   0, 0, 0), 
  new PVector( 300.0f/600*shapeSize, 0, 0), 
  new PVector( 150.0f/600*shapeSize, 0, -260.0f/600*shapeSize), 
  new PVector( 150.0f/600*shapeSize, -245.0f/600*shapeSize, -86.6f/600*shapeSize)
};
int verts = 4;

 
// "random" start point (mid point)
  if (currentDepth == 0) {
    
    point (currentPoint.x-150.0f/600*shapeSize, 245.0f/1700*shapeSize+currentPoint.y, 260.0f/1700*shapeSize+currentPoint.z);
    
    return;
  }
  for (int v=0; v<verts; v++) {
    sierpinski(new PVector(
        (currentPoint.x+coord[v].x)/2,
        (currentPoint.y+coord[v].y)/2,
        (currentPoint.z+coord[v].z)/2),
      currentDepth-1);
  }
}
}
class Sky {
float skyColor;

Sky(float skyColor){
  this.skyColor = skyColor;
}

 public void display(){
loadPixels();
// Loop through every pixel column
for (int x = 0; x < width; x++) {
   // Loop through every pixel row
  for (int y = 0; y < height; y++) {
      // Use the formula to find the 1D location
      int loc = x + y * width;
      pixels[loc] = color(skyColor,95, map(y , 0, height, 0, 50));
   }
}
updatePixels();
}
}
class Smile implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
  //variables for movement
  boolean shapeMovementDirection =true;
  int shapeMovementCount;
  int shapeMovementAmplitude = 60;
  float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
  float shapeMovementAcceleration = 0.1f;
  //variables for shrinking
  boolean shapeShrinkingDirection =true;
  int shapeShrinkingCount;
  int shapeShrinkingAmplitude = 200;
  float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
  float shapeShrinkingAcceleration = 0.1f;

  float shapeSize =100;
  int shapeColor = color(200, 100,58);
  float xRotation;
  float yRotation;
  float zRotation;
  float xRotationSpeed = 0;
  float yRotationSpeed = 0.0008f; 
  float zRotationSpeed = 0.0002f;


  Smile() {
   
   
  }
  
   public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude, float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
    this.xShape = xShape;
    this.yShape = yShape;
    this.zShape = zShape;
    this.shapeMovementAmplitude = shapeMovementAmplitude;
    this.shapeMovementAcceleration = shapeMovementAcceleration;
    this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
    this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
    this.shapeSize = shapeSize;
    this.shapeColor = shapeColor;
    this.xRotation = xRotation;
    this.yRotation = yRotation;
    this.zRotation = zRotation;
    this.xRotationSpeed =  xRotationSpeed;
    this.yRotationSpeed =  yRotationSpeed;
    this.zRotationSpeed =  zRotationSpeed;

}
  
   public void calculating() {
    //calculating movement behaviour
    if (shapeMovementDirection==true){
      shapeMovementVelocity+=shapeMovementAcceleration;
      shapeMovementCount++;
    }
    else{
      shapeMovementVelocity-=shapeMovementAcceleration;
      shapeMovementCount--;
    }
    if (shapeMovementCount==shapeMovementAmplitude){
    
      shapeMovementDirection =false;
    }
    if (shapeMovementCount==-shapeMovementAmplitude){
    
      shapeMovementDirection =true;
    }


    //calculating shrinking behaviour
    if (shapeShrinkingDirection==true){
      shapeShrinkingVelocity+=shapeShrinkingAcceleration;
      shapeShrinkingCount++;
    }
    else{
      shapeShrinkingVelocity-=shapeShrinkingAcceleration;
      shapeShrinkingCount--;
    }
    if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =false;
    }
    if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =true;
    }

    //changing angle of a shape
    xRotation+=xRotationSpeed;
    yRotation+=yRotationSpeed;
    zRotation+=zRotationSpeed;
  }
  
   public void display(){
    stroke(shapeColor);
    strokeWeight(4);
    
    pushMatrix();
    translate(xShape+shapeMovementVelocity,yShape, zShape);
    rotateX(xRotation);
    rotateY(yRotation);
    rotateZ(zRotation);


    //actually drawing the shape
    beginShape();
    for (float angle=0; angle<TWO_PI; angle+=0.01f){
      float x = shapeSize *cos(angle);
      float y = shapeSize*sin(angle);
      vertex(x,y+shapeMovementVelocity);
    }
    endShape();
    line(shapeSize*0.4f, -shapeSize*0.1f+shapeMovementVelocity, shapeSize*0.4f,-shapeSize*0.6f+shapeMovementVelocity);
    line(-shapeSize*0.4f, -shapeSize*0.1f+shapeMovementVelocity, -shapeSize*0.4f,-shapeSize*0.6f+shapeMovementVelocity);
    
    beginShape();
    for (float angle=PI/4; angle<HALF_PI+QUARTER_PI; angle+=0.01f){
      float x = shapeSize *cos(angle);
      float y = shapeSize*sin(angle);
      vertex(x,y-shapeSize*0.4f+shapeMovementVelocity);
    }
    endShape();
    popMatrix();
  }
}
class Sphere implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
  //variables for movement
  boolean shapeMovementDirection =true;
  int shapeMovementCount;
  int shapeMovementAmplitude = 60;
  float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
  float shapeMovementAcceleration = 0.1f;
  //variables for shrinking
  boolean shapeShrinkingDirection =true;
  int shapeShrinkingCount;
  int shapeShrinkingAmplitude = 200;
  float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
  float shapeShrinkingAcceleration = 0.1f;

  float shapeSize =100;
  int shapeColor = color(200, 100,58);
  float xRotation;
  float yRotation;
  float zRotation;
  float xRotationSpeed = 0;
  float yRotationSpeed = 0.0008f; 
  float zRotationSpeed = 0.0002f;


  Sphere(){
   
   
  }
  
   public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude, float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
    this.xShape = xShape;
    this.yShape = yShape;
    this.zShape = zShape;
    this.shapeMovementAmplitude = shapeMovementAmplitude;
    this.shapeMovementAcceleration = shapeMovementAcceleration;
    this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
    this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
    this.shapeSize = shapeSize;
    this.shapeColor = shapeColor;
    this.xRotation = xRotation;
    this.yRotation = yRotation;
    this.zRotation = zRotation;
    this.xRotationSpeed =  xRotationSpeed;
    this.yRotationSpeed =  yRotationSpeed;
    this.zRotationSpeed =  zRotationSpeed;

}
  
   public void calculating() {
    //calculating movement behaviour
    if (shapeMovementDirection==true){
      shapeMovementVelocity+=shapeMovementAcceleration;
      shapeMovementCount++;
    }
    else{
      shapeMovementVelocity-=shapeMovementAcceleration;
      shapeMovementCount--;
    }
    if (shapeMovementCount==shapeMovementAmplitude){
    
      shapeMovementDirection =false;
    }
    if (shapeMovementCount==-shapeMovementAmplitude){
    
      shapeMovementDirection =true;
    }


    //calculating shrinking behaviour
    if (shapeShrinkingDirection==true){
      shapeShrinkingVelocity+=shapeShrinkingAcceleration;
      shapeShrinkingCount++;
    }
    else{
      shapeShrinkingVelocity-=shapeShrinkingAcceleration;
      shapeShrinkingCount--;
    }
    if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =false;
    }
    if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =true;
    }

    //changing angle of a shape
    xRotation+=xRotationSpeed;
    yRotation+=yRotationSpeed;
    zRotation+=zRotationSpeed;
  }
   public void display(){
  strokeWeight(1.5f);
  stroke(shapeColor);
   pushMatrix();
    translate(xShape+shapeMovementVelocity,yShape, zShape);
    rotateX(xRotation);
    rotateY(yRotation);
    rotateZ(zRotation);
    sphereDetail(15);
    sphere(shapeSize+shapeShrinkingVelocity);
   popMatrix();
  }
}
class Sponge implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
  //variables for movement
  boolean shapeMovementDirection =true;
  int shapeMovementCount;
  int shapeMovementAmplitude = 60;
  float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
  float shapeMovementAcceleration = 0.1f;
  //variables for shrinking
  boolean shapeShrinkingDirection =true;
  int shapeShrinkingCount;
  int shapeShrinkingAmplitude = 200;
  float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
  float shapeShrinkingAcceleration = 0.1f;

  float shapeSize =100;
  int shapeColor = color(200, 100,58);
  float xRotation;
  float yRotation;
  float zRotation;
  float xRotationSpeed = 0;
  float yRotationSpeed = 0.0008f; 
  float zRotationSpeed = 0.0002f;
  ArrayList<Box> sponge;
  


  Sponge(){
   sponge = new ArrayList<Box>();

  // Star with one
  Box b = new Box(0, 0, 0, shapeSize);
  sponge.add(b);
  for (int i=1; i<3; i++){
  // Generate the next set of boxes
  ArrayList<Box> next = new ArrayList<Box>();
  for (Box c : sponge) {
    ArrayList<Box> newBoxes = c.generate();
    next.addAll(newBoxes);
  }
  sponge = next;
  }
   
  }
  
   public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude, float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
    this.xShape = xShape;
    this.yShape = yShape;
    this.zShape = zShape;
    this.shapeMovementAmplitude = shapeMovementAmplitude;
    this.shapeMovementAcceleration = shapeMovementAcceleration;
    this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
    this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
    this.shapeSize = shapeSize;
    this.shapeColor = shapeColor;
    this.xRotation = xRotation;
    this.yRotation = yRotation;
    this.zRotation = zRotation;
    this.xRotationSpeed =  xRotationSpeed;
    this.yRotationSpeed =  yRotationSpeed;
    this.zRotationSpeed =  zRotationSpeed;
    // An array of Box objects
  

}
  
   public void calculating() {
    //calculating movement behaviour
    if (shapeMovementDirection==true){
      shapeMovementVelocity+=shapeMovementAcceleration;
      shapeMovementCount++;
    }
    else{
      shapeMovementVelocity-=shapeMovementAcceleration;
      shapeMovementCount--;
    }
    if (shapeMovementCount==shapeMovementAmplitude){
    
      shapeMovementDirection =false;
    }
    if (shapeMovementCount==-shapeMovementAmplitude){
    
      shapeMovementDirection =true;
    }


    //calculating shrinking behaviour
    if (shapeShrinkingDirection==true){
      shapeShrinkingVelocity+=shapeShrinkingAcceleration;
      shapeShrinkingCount++;
    }
    else{
      shapeShrinkingVelocity-=shapeShrinkingAcceleration;
      shapeShrinkingCount--;
    }
    if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =false;
    }
    if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =true;
    }

    //changing angle of a shape
    xRotation+=xRotationSpeed;
    yRotation+=yRotationSpeed;
    zRotation+=zRotationSpeed;
  }
   public void display(){
  stroke((colors[5]+120)%360,100,100);
  strokeWeight(1);
   pushMatrix();
    translate(xShape+shapeMovementVelocity,yShape, zShape);
    rotateX(xRotation);
    rotateY(yRotation);
    rotateZ(zRotation);
    fill(color(colors[5],100,100));

    
    for (Box b : sponge) {
    b.show();
    }
    
   popMatrix();
   noFill();
  }
}
class Box {
  PVector pos;
  float r;

  Box(float x, float y, float z, float r_) {
    pos = new PVector(x, y, z);
    r = r_;
  }

   public ArrayList<Box> generate() {
    ArrayList<Box> boxes = new ArrayList<Box>();
    for (int x = -1; x < 2; x++) {
      for (int y = -1; y < 2; y++) {
        for (int z = -1; z < 2; z++) {
          int sum = abs(x) + abs(y) + abs(z);
          float newR = r/3;
          if (sum > 1) {
            Box b = new Box(pos.x+x*newR, pos.y+ y*newR, pos.z+z*newR, newR);
            boxes.add(b);
          }
        }
      }
    }
    return boxes;
  }

   public void show() {
    pushMatrix();
    translate(pos.x, pos.y, pos.z);
    
    box(r);
    popMatrix();
  }
}
class Star {
  // I create variables to specify the x and y of each star.
  float x;
  float y;
  // I create "z", a variable I'll use in a formula to modify the stars position.
  float z;

  // I create an other variable to store the previous value of the z variable.
  // (the value of the z variable at the previous frame).
  float pz;
  float speed;

  Star() {
    // I place values in the variables
    x = random(-width/2, width/2);
    // note: height and width are the same: the canvas is a square.
    y = random(-height/2, 0);
    // note: the z value can't exceed the width/2 (and height/2) value,
    // beacuse I'll use "z" as divisor of the "x" and "y",
    // whose values are also between "0" and "width/2".
    z = random(width/2);
    // I set the previous position of "z" in the same position of "z",
    // which it's like to say that the stars are not moving during the first frame.
    pz = z;
    speed = 2;
  }

   public void update() {
    // In the formula to set the new stars coordinates
    // I'll divide a value for the "z" value and the outcome will be
    // the new x-coordinate and y-coordinate of the star.
    // Which means if I decrease the value of "z" (which is a divisor),
    // the outcome will be bigger.
    // Wich means the more the speed value is bigger, the more the "z" decrease,
    // and the more the x and y coordinates increase.
    // Note: the "z" value is the first value I updated for the new frame.
    z = z - speed;
    // when the "z" value equals to 1, I'm sure the star have passed the
    // borders of the canvas( probably it's already far away from the borders),
    // so i can place it on more time in the canvas, with new x, y and z values.
    // Note: in this way I also avoid a potential division by 0.
    if (z < 1) {
      z = width/2;
      x = random(-width/2, width/2);
      y = random(-height/2, 0);
      pz = z;
    }
  }

   public void show() {
    fill(255);
    noStroke();

    // with theese "map", I get the new star positions
    // the division x / z get a number between 0 and a very high number,
    // we map this number (proportionally to a range of 0 - 1), inside a range of 0 - width/2.
    // In this way we are sure the new coordinates "sx" and "sy" move faster at each frame
    // and which they finish their travel outside of the canvas (they finish when "z" is less than a).

    float sx = map(x / z, 0, 1, 0, width/2);
    float sy = map(y / z, 0, 1, 0, height/2);;

    // I use the z value to increase the star size between a range from 0 to 16.
    float r = map(z, 0, width/2, 4, 0);
    ellipse(sx, sy, r, r);

    // Here i use the "pz" valute to get the previous position of the stars,
    // so I can draw a line from the previous position to the new (current) one.
    float px = map(x / pz, 0, 1, 0, width/2);
    float py = map(y / pz, 0, 1, 0, height/2);

    // Placing here this line of code, I'm sure the "pz" value are updated after the
    // coordinates are already calculated; in this way the "pz" value is always equals
    // to the "z" value of the previous frame.
    pz = z;

    stroke(255);
    line(px, py, sx, sy);
    
  }
  
}
class StarShape implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
  //variables for movement
  boolean shapeMovementDirection =true;
  int shapeMovementCount;
  int shapeMovementAmplitude = 60;
  float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
  float shapeMovementAcceleration = 0.1f;
  //variables for shrinking
  boolean shapeShrinkingDirection =true;
  int shapeShrinkingCount;
  int shapeShrinkingAmplitude = 200;
  float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
  float shapeShrinkingAcceleration = 0.1f;

  float shapeSize =100;
  int shapeColor = color(200, 100,58);
  float xRotation;
  float yRotation;
  float zRotation;
  float xRotationSpeed = 0;
  float yRotationSpeed = 0.0008f; 
  float zRotationSpeed = 0.0002f;

  StarShape() {
   
   
  }
  
    public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude, float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
    this.xShape = xShape;
    this.yShape = yShape;
    this.zShape = zShape;
    this.shapeMovementAmplitude = shapeMovementAmplitude;
    this.shapeMovementAcceleration = shapeMovementAcceleration;
    this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
    this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
    this.shapeSize = shapeSize;
    this.shapeColor = shapeColor;
    this.xRotation = xRotation;
    this.yRotation = yRotation;
    this.zRotation = zRotation;
    this.xRotationSpeed =  xRotationSpeed;
    this.yRotationSpeed =  yRotationSpeed;
    this.zRotationSpeed =  zRotationSpeed;

}
  
   public void calculating() {
    //calculating movement behaviour
    if (shapeMovementDirection==true){
      shapeMovementVelocity+=shapeMovementAcceleration;
      shapeMovementCount++;
    }
    else{
      shapeMovementVelocity-=shapeMovementAcceleration;
      shapeMovementCount--;
    }
    if (shapeMovementCount==shapeMovementAmplitude){
    
      shapeMovementDirection =false;
    }
    if (shapeMovementCount==-shapeMovementAmplitude){
    
      shapeMovementDirection =true;
    }


    //calculating shrinking behaviour
    if (shapeShrinkingDirection==true){
      shapeShrinkingVelocity+=shapeShrinkingAcceleration;
      shapeShrinkingCount++;
    }
    else{
      shapeShrinkingVelocity-=shapeShrinkingAcceleration;
      shapeShrinkingCount--;
    }
    if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =false;
    }
    if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =true;
    }

    //changing angle of a shape
    xRotation+=xRotationSpeed;
    yRotation+=yRotationSpeed;
    zRotation+=zRotationSpeed;
  }
  
    public void display(){
    stroke(shapeColor);
    strokeWeight(4);
    
    pushMatrix();
    
    translate(xShape+shapeMovementVelocity,yShape, zShape);
    rotateX(xRotation);
    rotateY(yRotation);
    rotateZ(zRotation);
    

    beginShape();
    
    for (int i=11; i>0; i--){
      float r = shapeSize*(i % 2 + 1)/2;
      float omega = TWO_PI / 10 * i;
      vertex((r * sin(omega)), (r * cos(omega)));
      
    }
    
    endShape();
    popMatrix();
   }
}
class StrangeHedron1 implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
  //variables for movement
  boolean shapeMovementDirection =true;
  int shapeMovementCount;
  int shapeMovementAmplitude = 60;
  float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
  float shapeMovementAcceleration = 0.1f;
  //variables for shrinking
  boolean shapeShrinkingDirection =true;
  int shapeShrinkingCount;
  int shapeShrinkingAmplitude = 200;
  float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
  float shapeShrinkingAcceleration = 0.1f;

  float shapeSize =100;
  int shapeColor = color(200, 100,58);
  float xRotation;
  float yRotation;
  float zRotation;
  float xRotationSpeed = 0;
  float yRotationSpeed = 0.0008f; 
  float zRotationSpeed = 0.0002f;


  StrangeHedron1(){
   
   
  }
  
   public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude, float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
    this.xShape = xShape;
    this.yShape = yShape;
    this.zShape = zShape;
    this.shapeMovementAmplitude = shapeMovementAmplitude;
    this.shapeMovementAcceleration = shapeMovementAcceleration;
    this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
    this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
    this.shapeSize = shapeSize;
    this.shapeColor = shapeColor;
    this.xRotation = xRotation;
    this.yRotation = yRotation;
    this.zRotation = zRotation;
    this.xRotationSpeed =  xRotationSpeed;
    this.yRotationSpeed =  yRotationSpeed;
    this.zRotationSpeed =  zRotationSpeed;

}
  
   public void calculating() {
    //calculating movement behaviour
    if (shapeMovementDirection==true){
      shapeMovementVelocity+=shapeMovementAcceleration;
      shapeMovementCount++;
    }
    else{
      shapeMovementVelocity-=shapeMovementAcceleration;
      shapeMovementCount--;
    }
    if (shapeMovementCount==shapeMovementAmplitude){
    
      shapeMovementDirection =false;
    }
    if (shapeMovementCount==-shapeMovementAmplitude){
    
      shapeMovementDirection =true;
    }


    //calculating shrinking behaviour
    if (shapeShrinkingDirection==true){
      shapeShrinkingVelocity+=shapeShrinkingAcceleration;
      shapeShrinkingCount++;
    }
    else{
      shapeShrinkingVelocity-=shapeShrinkingAcceleration;
      shapeShrinkingCount--;
    }
    if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =false;
    }
    if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =true;
    }

    //changing angle of a shape
    xRotation+=xRotationSpeed;
    yRotation+=yRotationSpeed;
    zRotation+=zRotationSpeed;
  }
   public void display(){
  strokeWeight(2.5f);
  stroke(shapeColor);
   pushMatrix();
    translate(xShape+shapeMovementVelocity,yShape, zShape);
    rotateX(xRotation);
    rotateY(yRotation);
    rotateZ(zRotation);
    sphereDetail(3);
    sphere(shapeSize+shapeShrinkingVelocity);
   popMatrix();
  }
}
class StrangeHedron2 implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
  //variables for movement
  boolean shapeMovementDirection =true;
  int shapeMovementCount;
  int shapeMovementAmplitude = 60;
  float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
  float shapeMovementAcceleration = 0.1f;
  //variables for shrinking
  boolean shapeShrinkingDirection =true;
  int shapeShrinkingCount;
  int shapeShrinkingAmplitude = 200;
  float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
  float shapeShrinkingAcceleration = 0.1f;

  float shapeSize =100;
  int shapeColor = color(200, 100,58);
  float xRotation;
  float yRotation;
  float zRotation;
  float xRotationSpeed = 0;
  float yRotationSpeed = 0.0008f; 
  float zRotationSpeed = 0.0002f;


  StrangeHedron2(){
   
   
  }
  
   public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude, float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
    this.xShape = xShape;
    this.yShape = yShape;
    this.zShape = zShape;
    this.shapeMovementAmplitude = shapeMovementAmplitude;
    this.shapeMovementAcceleration = shapeMovementAcceleration;
    this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
    this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
    this.shapeSize = shapeSize;
    this.shapeColor = shapeColor;
    this.xRotation = xRotation;
    this.yRotation = yRotation;
    this.zRotation = zRotation;
    this.xRotationSpeed =  xRotationSpeed;
    this.yRotationSpeed =  yRotationSpeed;
    this.zRotationSpeed =  zRotationSpeed;

}
  
   public void calculating() {
    //calculating movement behaviour
    if (shapeMovementDirection==true){
      shapeMovementVelocity+=shapeMovementAcceleration;
      shapeMovementCount++;
    }
    else{
      shapeMovementVelocity-=shapeMovementAcceleration;
      shapeMovementCount--;
    }
    if (shapeMovementCount==shapeMovementAmplitude){
    
      shapeMovementDirection =false;
    }
    if (shapeMovementCount==-shapeMovementAmplitude){
    
      shapeMovementDirection =true;
    }


    //calculating shrinking behaviour
    if (shapeShrinkingDirection==true){
      shapeShrinkingVelocity+=shapeShrinkingAcceleration;
      shapeShrinkingCount++;
    }
    else{
      shapeShrinkingVelocity-=shapeShrinkingAcceleration;
      shapeShrinkingCount--;
    }
    if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =false;
    }
    if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =true;
    }

    //changing angle of a shape
    xRotation+=xRotationSpeed;
    yRotation+=yRotationSpeed;
    zRotation+=zRotationSpeed;
  }
   public void display(){
  strokeWeight(2.5f);
  stroke(shapeColor);
   pushMatrix();
    translate(xShape+shapeMovementVelocity,yShape, zShape);
    rotateX(xRotation);
    rotateY(yRotation);
    rotateZ(zRotation);
    sphereDetail(4);
    sphere(shapeSize+shapeShrinkingVelocity);
   popMatrix();
  }
}
class StrangeHedron3 implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
  //variables for movement
  boolean shapeMovementDirection =true;
  int shapeMovementCount;
  int shapeMovementAmplitude = 60;
  float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
  float shapeMovementAcceleration = 0.1f;
  //variables for shrinking
  boolean shapeShrinkingDirection =true;
  int shapeShrinkingCount;
  int shapeShrinkingAmplitude = 200;
  float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
  float shapeShrinkingAcceleration = 0.1f;

  float shapeSize =100;
  int shapeColor = color(200, 100,58);
  float xRotation;
  float yRotation;
  float zRotation;
  float xRotationSpeed = 0;
  float yRotationSpeed = 0.0008f; 
  float zRotationSpeed = 0.0002f;


  StrangeHedron3(){
   
   
  }
  
   public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude, float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
    this.xShape = xShape;
    this.yShape = yShape;
    this.zShape = zShape;
    this.shapeMovementAmplitude = shapeMovementAmplitude;
    this.shapeMovementAcceleration = shapeMovementAcceleration;
    this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
    this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
    this.shapeSize = shapeSize;
    this.shapeColor = shapeColor;
    this.xRotation = xRotation;
    this.yRotation = yRotation;
    this.zRotation = zRotation;
    this.xRotationSpeed =  xRotationSpeed;
    this.yRotationSpeed =  yRotationSpeed;
    this.zRotationSpeed =  zRotationSpeed;

}
  
   public void calculating() {
    //calculating movement behaviour
    if (shapeMovementDirection==true){
      shapeMovementVelocity+=shapeMovementAcceleration;
      shapeMovementCount++;
    }
    else{
      shapeMovementVelocity-=shapeMovementAcceleration;
      shapeMovementCount--;
    }
    if (shapeMovementCount==shapeMovementAmplitude){
    
      shapeMovementDirection =false;
    }
    if (shapeMovementCount==-shapeMovementAmplitude){
    
      shapeMovementDirection =true;
    }


    //calculating shrinking behaviour
    if (shapeShrinkingDirection==true){
      shapeShrinkingVelocity+=shapeShrinkingAcceleration;
      shapeShrinkingCount++;
    }
    else{
      shapeShrinkingVelocity-=shapeShrinkingAcceleration;
      shapeShrinkingCount--;
    }
    if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =false;
    }
    if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =true;
    }

    //changing angle of a shape
    xRotation+=xRotationSpeed;
    yRotation+=yRotationSpeed;
    zRotation+=zRotationSpeed;
  }
   public void display(){
  strokeWeight(2.5f);
  stroke(shapeColor);
   pushMatrix();
    translate(xShape+shapeMovementVelocity,yShape, zShape);
    rotateX(xRotation);
    rotateY(yRotation);
    rotateZ(zRotation);
    sphereDetail(5);
    sphere(shapeSize+shapeShrinkingVelocity);
   popMatrix();
  }
}
class SuperShape3D1 implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
//variables for movement
boolean shapeMovementDirection =true;
int shapeMovementCount;
int shapeMovementAmplitude = 60;
float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
float shapeMovementAcceleration = 0.1f;
//variables for shrinking
boolean shapeShrinkingDirection =true;
int shapeShrinkingCount;
int shapeShrinkingAmplitude = 200;
float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
float shapeShrinkingAcceleration = 0.1f;

float shapeSize =200;
int  shapeColor = color(200, 100,58);
float xRotation;
float yRotation;
float zRotation;
float xRotationSpeed = 0;
float yRotationSpeed = 0.0008f; 
float zRotationSpeed = 0.0002f;
//supershape variables
float total = 60;
float m = 7;
float a = 1;
float b = 1;
float osc = 0;
PVector[][] globe;


SuperShape3D1(){}

SuperShape3D1(float m, float a, float b, float osc){
  this.m = m;
  this.a = a;
  this.b = b;
  this.total = 75;
  this.osc = osc;
}

 public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude,float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
  this.xShape = xShape;
  this.yShape = yShape;
  this.zShape = zShape;
  this.shapeMovementAmplitude = shapeMovementAmplitude;
  this.shapeMovementAcceleration = shapeMovementAcceleration;
  this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
  this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
  this.shapeSize = shapeSize;
  this.shapeColor = shapeColor;
  this.xRotation = xRotation;
  this.yRotation = yRotation;
  this.zRotation = zRotation;
  this.xRotationSpeed =  xRotationSpeed;
  this.yRotationSpeed =  yRotationSpeed;
  this.zRotationSpeed =  zRotationSpeed;
  globe = new PVector[61][61];

}
  
 public void calculating() {
if (shapeMovementDirection==true){
    shapeMovementVelocity+=shapeMovementAcceleration;
    shapeMovementCount++;
  }
  else{
    shapeMovementVelocity-=shapeMovementAcceleration;
    shapeMovementCount--;
  }
if (shapeMovementCount==shapeMovementAmplitude){
    
  shapeMovementDirection =false;
}
if (shapeMovementCount==-shapeMovementAmplitude){
    
  shapeMovementDirection =true;
}


//calculating shrinking behaviour
if (shapeShrinkingDirection==true){
    shapeShrinkingVelocity+=shapeShrinkingAcceleration;
    shapeShrinkingCount++;
  }
  else{
    shapeShrinkingVelocity-=shapeShrinkingAcceleration;
    shapeShrinkingCount--;
  }
if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
  shapeShrinkingDirection =false;
}
if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
  shapeShrinkingDirection =true;
}

//changing angle of a shape
xRotation+=xRotationSpeed;
yRotation+=yRotationSpeed;
zRotation+=zRotationSpeed;

osc += 0.01f;
m = map(sin(osc), -1, 1, 4, 7);
   

}
 public void display(){
  
stroke(shapeColor);
strokeWeight(0.3f);
noFill();
 
pushMatrix();
translate(xShape+shapeMovementVelocity,yShape, zShape); 
rotateX(xRotation);
rotateY(yRotation);
rotateZ(zRotation);
  
  
  
for (int i = 0; i < total+1; i++) {
    float lat = map(i, 0, total, -HALF_PI, HALF_PI);
    float r2 = supershape(lat, m, 0.2f, 1.7f, 1.7f);
    //float r2 = supershape(lat, 2, 10, 10, 10);
    for (int j = 0; j < total+1; j++) {
      float lon = map(j, 0, total, -PI, PI);
      float r1 = supershape(lon, m, 0.2f, 1.7f, 1.7f);
      //float r1 = supershape(lon, 8, 60, 100, 30);
      float x = shapeSize * r1 * cos(lon) * r2 * cos(lat);
      float y = shapeSize * r1 * sin(lon) * r2 * cos(lat);
      float z = shapeSize * r2 * sin(lat);
      globe[i][j] = new PVector(x, y, z);
    }
  }
for (int i = 0; i < total; i++) {
    //float hu = map(i, 0, total, 0, 255*6);
    //fill((hu + offset) % 255 , 255, 255);
    beginShape(TRIANGLE_STRIP);
    for (int j = 0; j < total+1; j++) {
      PVector v1 = globe[i][j];
      vertex(v1.x, v1.y, v1.z);
      PVector v2 = globe[i+1][j];
      vertex(v2.x, v2.y, v2.z);
    }
    endShape();
  }
popMatrix();
strokeWeight(4);
}

 public float supershape(float theta, float m, float n1, float n2, float n3) {
  float t1 = abs((1/a)*cos(m * theta / 4));
  t1 = pow(t1, n2);
  float t2 = abs((1/b)*sin(m * theta/4));
  t2 = pow(t2, n3);
  float t3 = t1 + t2;
  float r = pow(t3, - 1 / n1);
  return r;
}
}
class SuperShape3D2 implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
//variables for movement
boolean shapeMovementDirection =true;
int shapeMovementCount;
int shapeMovementAmplitude = 60;
float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
float shapeMovementAcceleration = 0.1f;
//variables for shrinking
boolean shapeShrinkingDirection =true;
int shapeShrinkingCount;
int shapeShrinkingAmplitude = 200;
float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
float shapeShrinkingAcceleration = 0.1f;

float shapeSize =200;
int  shapeColor = color(200, 100,58);
float xRotation;
float yRotation;
float zRotation;
float xRotationSpeed = 0;
float yRotationSpeed = 0.0008f; 
float zRotationSpeed = 0.0002f;
//supershape variables
float total = 40;
float m = 5;
float a = 1;
float b = 1;
float osc = 0;
PVector[][] globe;


SuperShape3D2(){}

SuperShape3D2(float m, float a, float b, float osc){
  this.m = m;
  this.a = a;
  this.b = b;
  this.total = 75;
  this.osc = osc;
}

 public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude,float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
  this.xShape = xShape;
  this.yShape = yShape;
  this.zShape = zShape;
  this.shapeMovementAmplitude = shapeMovementAmplitude;
  this.shapeMovementAcceleration = shapeMovementAcceleration;
  this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
  this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
  this.shapeSize = shapeSize;
  this.shapeColor = shapeColor;
  this.xRotation = xRotation;
  this.yRotation = yRotation;
  this.zRotation = zRotation;
  this.xRotationSpeed =  xRotationSpeed;
  this.yRotationSpeed =  yRotationSpeed;
  this.zRotationSpeed =  zRotationSpeed;
  globe = new PVector[76][76];

}
  
 public void calculating() {
if (shapeMovementDirection==true){
    shapeMovementVelocity+=shapeMovementAcceleration;
    shapeMovementCount++;
  }
  else{
    shapeMovementVelocity-=shapeMovementAcceleration;
    shapeMovementCount--;
  }
if (shapeMovementCount==shapeMovementAmplitude){
    
  shapeMovementDirection =false;
}
if (shapeMovementCount==-shapeMovementAmplitude){
    
  shapeMovementDirection =true;
}


//calculating shrinking behaviour
if (shapeShrinkingDirection==true){
    shapeShrinkingVelocity+=shapeShrinkingAcceleration;
    shapeShrinkingCount++;
  }
  else{
    shapeShrinkingVelocity-=shapeShrinkingAcceleration;
    shapeShrinkingCount--;
  }
if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
  shapeShrinkingDirection =false;
}
if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
  shapeShrinkingDirection =true;
}

//changing angle of a shape
xRotation+=xRotationSpeed;
yRotation+=yRotationSpeed;
zRotation+=zRotationSpeed;


osc += 0.01f;
m = map(sin(osc), -1, 1, 4, 7);
}
 public void display(){
  
stroke(shapeColor);
strokeWeight(0.3f);
noFill();
 
pushMatrix();
translate(xShape+shapeMovementVelocity,yShape, zShape); 
rotateX(xRotation);
rotateY(yRotation);
rotateZ(zRotation);
  
  
  
for (int i = 0; i < total+1; i++) {
    float lat = map(i, 0, total, -HALF_PI, HALF_PI);
    float r2 = supershape(lat, 1, 0.3f, 0.5f, 0.5f);
    //float r2 = supershape(lat, 2, 10, 10, 10);
    for (int j = 0; j < total+1; j++) {
      float lon = map(j, 0, total, -PI, PI);
      float r1 = supershape(lon, m, 0.1f, 1.7f, 1.7f);
      //float r1 = supershape(lon, 8, 60, 100, 30);
      float x = shapeSize * r1 * cos(lon) * r2 * cos(lat);
      float y = shapeSize * r1 * sin(lon) * r2 * cos(lat);
      float z = shapeSize * r2 * sin(lat);
      globe[i][j] = new PVector(x, y, z);
    }
  }
for (int i = 0; i < total; i++) {
    //float hu = map(i, 0, total, 0, 255*6);
    //fill((hu + offset) % 255 , 255, 255);
    beginShape(TRIANGLE_STRIP);
    for (int j = 0; j < total+1; j++) {
      PVector v1 = globe[i][j];
      vertex(v1.x, v1.y, v1.z);
      PVector v2 = globe[i+1][j];
      vertex(v2.x, v2.y, v2.z);
    }
    endShape();
  }
popMatrix();
strokeWeight(4);
}

 public float supershape(float theta, float m, float n1, float n2, float n3) {
  float t1 = abs((1/a)*cos(m * theta / 4));
  t1 = pow(t1, n2);
  float t2 = abs((1/b)*sin(m * theta/4));
  t2 = pow(t2, n3);
  float t3 = t1 + t2;
  float r = pow(t3, - 1 / n1);
  return r;
}
}
class SuperShape3D3 implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
//variables for movement
boolean shapeMovementDirection =true;
int shapeMovementCount;
int shapeMovementAmplitude = 60;
float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
float shapeMovementAcceleration = 0.1f;
//variables for shrinking
boolean shapeShrinkingDirection =true;
int shapeShrinkingCount;
int shapeShrinkingAmplitude = 200;
float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
float shapeShrinkingAcceleration = 0.1f;

float shapeSize =200;
int  shapeColor = color(200, 100,58);
float xRotation;
float yRotation;
float zRotation;
float xRotationSpeed = 0;
float yRotationSpeed = 0.0008f; 
float zRotationSpeed = 0.0002f;
//supershape variables
float total = 40;
float m = 5;
float a = 1;
float b = 1;
float osc = 0;
PVector[][] globe;


SuperShape3D3(){}

SuperShape3D3(float m, float a, float b, float osc){
  this.m = m;
  this.a = a;
  this.b = b;
  this.total = 75;
  this.osc = osc;
}

 public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude,float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
  this.xShape = xShape;
  this.yShape = yShape;
  this.zShape = zShape;
  this.shapeMovementAmplitude = shapeMovementAmplitude;
  this.shapeMovementAcceleration = shapeMovementAcceleration;
  this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
  this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
  this.shapeSize = shapeSize;
  this.shapeColor = shapeColor;
  this.xRotation = xRotation;
  this.yRotation = yRotation;
  this.zRotation = zRotation;
  this.xRotationSpeed =  xRotationSpeed;
  this.yRotationSpeed =  yRotationSpeed;
  this.zRotationSpeed =  zRotationSpeed;
  globe = new PVector[76][76];

}
  
 public void calculating() {
if (shapeMovementDirection==true){
    shapeMovementVelocity+=shapeMovementAcceleration;
    shapeMovementCount++;
  }
  else{
    shapeMovementVelocity-=shapeMovementAcceleration;
    shapeMovementCount--;
  }
if (shapeMovementCount==shapeMovementAmplitude){
    
  shapeMovementDirection =false;
}
if (shapeMovementCount==-shapeMovementAmplitude){
    
  shapeMovementDirection =true;
}


//calculating shrinking behaviour
if (shapeShrinkingDirection==true){
    shapeShrinkingVelocity+=shapeShrinkingAcceleration;
    shapeShrinkingCount++;
  }
  else{
    shapeShrinkingVelocity-=shapeShrinkingAcceleration;
    shapeShrinkingCount--;
  }
if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
  shapeShrinkingDirection =false;
}
if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
  shapeShrinkingDirection =true;
}

//changing angle of a shape
xRotation+=xRotationSpeed;
yRotation+=yRotationSpeed;
zRotation+=zRotationSpeed;


osc += 0.01f;
m = map(sin(osc), -1, 1, 1, 4);
}
 public void display(){
  
stroke(shapeColor);
strokeWeight(0.3f);
noFill();
 
pushMatrix();
translate(xShape+shapeMovementVelocity,yShape, zShape); 
rotateX(xRotation);
rotateY(yRotation);
rotateZ(zRotation);
  
  
  
for (int i = 0; i < total+1; i++) {
    float lat = map(i, 0, total, -HALF_PI, HALF_PI);
    float r2 = supershape(lat, m, 0.5f, 0.2f, 0.2f);
    //float r2 = supershape(lat, 2, 10, 10, 10);
    for (int j = 0; j < total+1; j++) {
      float lon = map(j, 0, total, -PI, PI);
      float r1 = supershape(lon, 0.2f, 0.1f, 1.7f, 1.7f);
      //float r1 = supershape(lon, 8, 60, 100, 30);
      float x = shapeSize * r1 * cos(lon) * r2 * cos(lat);
      float y = shapeSize * r1 * sin(lon) * r2 * cos(lat);
      float z = shapeSize * r2 * sin(lat);
      globe[i][j] = new PVector(x, y, z);
    }
  }
for (int i = 0; i < total; i++) {
    //float hu = map(i, 0, total, 0, 255*6);
    //fill((hu + offset) % 255 , 255, 255);
    beginShape(TRIANGLE_STRIP);
    for (int j = 0; j < total+1; j++) {
      PVector v1 = globe[i][j];
      vertex(v1.x, v1.y, v1.z);
      PVector v2 = globe[i+1][j];
      vertex(v2.x, v2.y, v2.z);
    }
    endShape();
  }
popMatrix();
strokeWeight(4);
}

 public float supershape(float theta, float m, float n1, float n2, float n3) {
  float t1 = abs((1/a)*cos(m * theta / 4));
  t1 = pow(t1, n2);
  float t2 = abs((1/b)*sin(m * theta/4));
  t2 = pow(t2, n3);
  float t3 = t1 + t2;
  float r = pow(t3, - 1 / n1);
  return r;
}
}
class Trans implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
  //variables for movement
  boolean shapeMovementDirection =true;
  int shapeMovementCount;
  int shapeMovementAmplitude = 60;
  float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
  float shapeMovementAcceleration = 0.1f;
  //variables for shrinking
  boolean shapeShrinkingDirection =true;
  int shapeShrinkingCount;
  int shapeShrinkingAmplitude = 200;
  float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
  float shapeShrinkingAcceleration = 0.1f;

  float shapeSize =100;
  int shapeColor = color(200, 100,58);
  float xRotation;
  float yRotation;
  float zRotation;
  float xRotationSpeed = 0;
  float yRotationSpeed = 0.0008f; 
  float zRotationSpeed = 0.0002f;


  Trans(){
   
   
  }
  
   public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude, float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
    this.xShape = xShape;
    this.yShape = yShape;
    this.zShape = zShape;
    this.shapeMovementAmplitude = shapeMovementAmplitude;
    this.shapeMovementAcceleration = shapeMovementAcceleration;
    this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
    this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
    this.shapeSize = shapeSize;
    this.shapeColor = shapeColor;
    this.xRotation = xRotation;
    this.yRotation = yRotation;
    this.zRotation = zRotation;
    this.xRotationSpeed =  xRotationSpeed;
    this.yRotationSpeed =  yRotationSpeed;
    this.zRotationSpeed =  zRotationSpeed;

}
  
   public void calculating() {
    //calculating movement behaviour
    if (shapeMovementDirection==true){
      shapeMovementVelocity+=shapeMovementAcceleration;
      shapeMovementCount++;
    }
    else{
      shapeMovementVelocity-=shapeMovementAcceleration;
      shapeMovementCount--;
    }
    if (shapeMovementCount==shapeMovementAmplitude){
    
      shapeMovementDirection =false;
    }
    if (shapeMovementCount==-shapeMovementAmplitude){
    
      shapeMovementDirection =true;
    }


    //calculating shrinking behaviour
    if (shapeShrinkingDirection==true){
      shapeShrinkingVelocity+=shapeShrinkingAcceleration;
      shapeShrinkingCount++;
    }
    else{
      shapeShrinkingVelocity-=shapeShrinkingAcceleration;
      shapeShrinkingCount--;
    }
    if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =false;
    }
    if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =true;
    }

    //changing angle of a shape
    xRotation+=xRotationSpeed;
    yRotation+=yRotationSpeed;
    zRotation+=zRotationSpeed;
  }
   public void display(){
  strokeWeight(4);
  stroke(shapeColor);
   pushMatrix();
    translate(xShape+shapeMovementVelocity,yShape, zShape);
    rotateX(xRotation);
    rotateY(yRotation);
    rotateZ(zRotation);
    
    beginShape();
for (float angle=0; angle<TWO_PI; angle+=0.01f){
  float x = shapeSize *cos(angle);
  float y = shapeSize*sin(angle);
  vertex(x,y);
}

endShape();
line(shapeSize *cos(HALF_PI), shapeSize*sin(HALF_PI), shapeSize *cos(HALF_PI), shapeSize*sin(HALF_PI)+shapeSize*1.4f);
line(shapeSize *cos(HALF_PI)-shapeSize/2, shapeSize*sin(HALF_PI)+shapeSize/2, shapeSize *cos(HALF_PI)+shapeSize/2, shapeSize*sin(HALF_PI)+shapeSize/2);

rotateZ(-HALF_PI-QUARTER_PI);

beginShape();
    for (float angle=0; angle<TWO_PI; angle+=0.01f){
      float x = shapeSize *cos(angle);
      float y = shapeSize*sin(angle);
      vertex(x,y);
    }
    
    endShape();
    line(shapeSize *cos(HALF_PI), shapeSize*sin(HALF_PI), shapeSize *cos(HALF_PI), shapeSize*sin(HALF_PI)+shapeSize*1.4f);
line(shapeSize *cos(HALF_PI), shapeSize*sin(HALF_PI)+shapeSize*1.4f,shapeSize *cos(HALF_PI)-shapeSize/2, shapeSize*sin(HALF_PI)+shapeSize*1.4f-shapeSize/2 );
    line(shapeSize *cos(HALF_PI), shapeSize*sin(HALF_PI)+shapeSize*1.4f,shapeSize *cos(HALF_PI)+shapeSize/2, shapeSize*sin(HALF_PI)+shapeSize*1.4f-shapeSize/2 );

rotateZ(-HALF_PI);
beginShape();
for (float angle=0; angle<TWO_PI; angle+=0.01f){
  float x = shapeSize *cos(angle);
  float y = shapeSize*sin(angle);
  vertex(x,y);
}

endShape();
line(shapeSize *cos(HALF_PI), shapeSize*sin(HALF_PI), shapeSize *cos(HALF_PI), shapeSize*sin(HALF_PI)+shapeSize*1.4f);
line(shapeSize *cos(HALF_PI)-shapeSize/2, shapeSize*sin(HALF_PI)+shapeSize/2, shapeSize *cos(HALF_PI)+shapeSize/2, shapeSize*sin(HALF_PI)+shapeSize/2);



beginShape();
    for (float angle=0; angle<TWO_PI; angle+=0.01f){
      float x = shapeSize *cos(angle);
      float y = shapeSize*sin(angle);
      vertex(x,y);
    }
    
    endShape();
    line(shapeSize *cos(HALF_PI), shapeSize*sin(HALF_PI), shapeSize *cos(HALF_PI), shapeSize*sin(HALF_PI)+shapeSize*1.4f);
line(shapeSize *cos(HALF_PI), shapeSize*sin(HALF_PI)+shapeSize*1.4f,shapeSize *cos(HALF_PI)-shapeSize/2, shapeSize*sin(HALF_PI)+shapeSize*1.4f-shapeSize/2 );
    line(shapeSize *cos(HALF_PI), shapeSize*sin(HALF_PI)+shapeSize*1.4f,shapeSize *cos(HALF_PI)+shapeSize/2, shapeSize*sin(HALF_PI)+shapeSize*1.4f-shapeSize/2 );

    
    
    
   popMatrix();
  }
}
class Triangle implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
  //variables for movement
  boolean shapeMovementDirection =true;
  int shapeMovementCount;
  int shapeMovementAmplitude = 60;
  float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
  float shapeMovementAcceleration = 0.1f;
  //variables for shrinking
  boolean shapeShrinkingDirection =true;
  int shapeShrinkingCount;
  int shapeShrinkingAmplitude = 200;
  float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
  float shapeShrinkingAcceleration = 0.1f;

  float shapeSize =100;
  int shapeColor = color(200, 100,58);
  float xRotation;
  float yRotation;
  float zRotation;
  float xRotationSpeed = 0;
  float yRotationSpeed = 0.0008f; 
  float zRotationSpeed = 0.0002f;


  Triangle() {
   
   
  }
  
   public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude, float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
    this.xShape = xShape;
    this.yShape = yShape;
    this.zShape = zShape;
    this.shapeMovementAmplitude = shapeMovementAmplitude;
    this.shapeMovementAcceleration = shapeMovementAcceleration;
    this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
    this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
    this.shapeSize = shapeSize;
    this.shapeColor = shapeColor;
    this.xRotation = xRotation;
    this.yRotation = yRotation;
    this.zRotation = zRotation;
    this.xRotationSpeed =  xRotationSpeed;
    this.yRotationSpeed =  yRotationSpeed;
    this.zRotationSpeed =  zRotationSpeed;

}
  
   public void calculating() {
    //calculating movement behaviour
    if (shapeMovementDirection==true){
      shapeMovementVelocity+=shapeMovementAcceleration;
      shapeMovementCount++;
    }
    else{
      shapeMovementVelocity-=shapeMovementAcceleration;
      shapeMovementCount--;
    }
    if (shapeMovementCount==shapeMovementAmplitude){
    
      shapeMovementDirection =false;
    }
    if (shapeMovementCount==-shapeMovementAmplitude){
    
      shapeMovementDirection =true;
    }


    //calculating shrinking behaviour
    if (shapeShrinkingDirection==true){
      shapeShrinkingVelocity+=shapeShrinkingAcceleration;
      shapeShrinkingCount++;
    }
    else{
      shapeShrinkingVelocity-=shapeShrinkingAcceleration;
      shapeShrinkingCount--;
    }
    if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =false;
    }
    if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =true;
    }

    //changing angle of a shape
    xRotation+=xRotationSpeed;
    yRotation+=yRotationSpeed;
    zRotation+=zRotationSpeed;
  }
  
   public void display(){
    stroke(shapeColor);
    strokeWeight(4);
    
    pushMatrix();
    translate(xShape+shapeMovementVelocity,yShape, zShape);
    rotateX(xRotation);
    rotateY(yRotation);
    rotateZ(zRotation);


    //actually drawing the shape
    beginShape(LINES);

    vertex(shapeSize+shapeMovementVelocity+shapeShrinkingVelocity, (-shapeSize+shapeMovementVelocity+shapeShrinkingVelocity)/sqrt(3),(-shapeSize+shapeMovementVelocity+shapeShrinkingVelocity)/sqrt(6));
    vertex(-shapeSize+shapeMovementVelocity+shapeShrinkingVelocity, (-shapeSize+shapeMovementVelocity+shapeShrinkingVelocity)/sqrt(3),(-shapeSize+shapeMovementVelocity+shapeShrinkingVelocity)/sqrt(6));

    vertex(-shapeSize+shapeMovementVelocity+shapeShrinkingVelocity, (-shapeSize+shapeMovementVelocity+shapeShrinkingVelocity)/sqrt(3),(-shapeSize+shapeMovementVelocity+shapeShrinkingVelocity)/sqrt(6));
    vertex(+shapeMovementVelocity+shapeShrinkingVelocity, 2*(shapeSize+shapeMovementVelocity+shapeShrinkingVelocity)/sqrt(3), (-shapeSize+shapeMovementVelocity+shapeShrinkingVelocity)/sqrt(6));

    vertex(shapeSize+shapeMovementVelocity+shapeShrinkingVelocity, (-shapeSize+shapeMovementVelocity+shapeShrinkingVelocity)/sqrt(3),(-shapeSize+shapeMovementVelocity+shapeShrinkingVelocity)/sqrt(6));
    vertex(+shapeMovementVelocity+shapeShrinkingVelocity, 2*(shapeSize+shapeMovementVelocity+shapeShrinkingVelocity)/sqrt(3), (-shapeSize+shapeMovementVelocity+shapeShrinkingVelocity)/sqrt(6));
    endShape();
    popMatrix();
  }
}
class Veneric implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
  //variables for movement
  boolean shapeMovementDirection =true;
  int shapeMovementCount;
  int shapeMovementAmplitude = 60;
  float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
  float shapeMovementAcceleration = 0.1f;
  //variables for shrinking
  boolean shapeShrinkingDirection =true;
  int shapeShrinkingCount;
  int shapeShrinkingAmplitude = 200;
  float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
  float shapeShrinkingAcceleration = 0.1f;

  float shapeSize =10;
  int shapeColor = color(188, 70,165);
  float xRotation;
  float yRotation;
  float zRotation;
  float xRotationSpeed = 0;
  float yRotationSpeed = 0.0008f; 
  float zRotationSpeed = 0.0002f;

//сюда передаём значения особых переменных
Veneric() {

}

//общие переменные
 public void setuping(float xShape, float yShape, float zShape,int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude, float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
  this.xShape = xShape;
  this.yShape = yShape;
  this.zShape = zShape;
  this.shapeMovementAmplitude = shapeMovementAmplitude;
  this.shapeMovementAcceleration = shapeMovementAcceleration;
  this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
  this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
  this.shapeSize = shapeSize;
  this.shapeColor = shapeColor;
  this.xRotation = xRotation;
  this.yRotation = yRotation;
  this.zRotation = zRotation;
  this.xRotationSpeed =  xRotationSpeed;
  this.yRotationSpeed =  yRotationSpeed;
  this.zRotationSpeed =  zRotationSpeed;

}


 public void calculating() {
  //calculating movement behaviour
if (shapeMovementDirection==true){
    shapeMovementVelocity+=shapeMovementAcceleration;
    shapeMovementCount++;
  }
  else{
    shapeMovementVelocity-=shapeMovementAcceleration;
    shapeMovementCount--;
  }
if (shapeMovementCount==shapeMovementAmplitude){
    
  shapeMovementDirection =false;
}
if (shapeMovementCount==-shapeMovementAmplitude){
    
  shapeMovementDirection =true;
}


//calculating shrinking behaviour
if (shapeShrinkingDirection==true){
    shapeShrinkingVelocity+=shapeShrinkingAcceleration;
    shapeShrinkingCount++;
  }
  else{
    shapeShrinkingVelocity-=shapeShrinkingAcceleration;
    shapeShrinkingCount--;
  }
if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
  shapeShrinkingDirection =false;
}
if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
  shapeShrinkingDirection =true;
}

//changing angle of a shape
xRotation+=xRotationSpeed;
yRotation+=yRotationSpeed;
zRotation+=zRotationSpeed;

}

 public void display() {

stroke(shapeColor);
noFill();
strokeWeight(4);

pushMatrix();
translate(xShape+shapeMovementVelocity,yShape, zShape);
rotateX(xRotation);
rotateY(yRotation);
rotateZ(zRotation);

beginShape();
for (float angle=0; angle<TWO_PI; angle+=0.01f){
  float x = shapeSize *cos(angle);
  float y = shapeSize*sin(angle);
  vertex(x,y);
}

endShape();
line(shapeSize *cos(HALF_PI), shapeSize*sin(HALF_PI), shapeSize *cos(HALF_PI), shapeSize*sin(HALF_PI)+shapeSize*1.4f);
line(shapeSize *cos(HALF_PI)-shapeSize/2, shapeSize*sin(HALF_PI)+shapeSize/2, shapeSize *cos(HALF_PI)+shapeSize/2, shapeSize*sin(HALF_PI)+shapeSize/2);
popMatrix();
}
}
class WindRose implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
  //variables for movement
  boolean shapeMovementDirection =true;
  int shapeMovementCount;
  int shapeMovementAmplitude = 60;
  float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
  float shapeMovementAcceleration = 0.1f;
  //variables for shrinking
  boolean shapeShrinkingDirection =true;
  int shapeShrinkingCount;
  int shapeShrinkingAmplitude = 200;
  float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
  float shapeShrinkingAcceleration = 0.1f;

  float shapeSize =10;
  int shapeColor = color(188, 70,165);
  float xRotation;
  float yRotation;
  float zRotation;
  float xRotationSpeed = 0;
  float yRotationSpeed = 0.0008f; 
  float zRotationSpeed = 0.0002f;

//сюда передаём значения особых переменных
WindRose() {

}

//общие переменные
 public void setuping(float xShape, float yShape, float zShape,int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude, float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
  this.xShape = xShape;
  this.yShape = yShape;
  this.zShape = zShape;
  this.shapeMovementAmplitude = shapeMovementAmplitude;
  this.shapeMovementAcceleration = shapeMovementAcceleration;
  this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
  this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
  this.shapeSize = shapeSize;
  this.shapeColor = shapeColor;
  this.xRotation = xRotation;
  this.yRotation = yRotation;
  this.zRotation = zRotation;
  this.xRotationSpeed =  xRotationSpeed;
  this.yRotationSpeed =  yRotationSpeed;
  this.zRotationSpeed =  zRotationSpeed;

}


 public void calculating() {
  //calculating movement behaviour
if (shapeMovementDirection==true){
    shapeMovementVelocity+=shapeMovementAcceleration;
    shapeMovementCount++;
  }
  else{
    shapeMovementVelocity-=shapeMovementAcceleration;
    shapeMovementCount--;
  }
if (shapeMovementCount==shapeMovementAmplitude){
    
  shapeMovementDirection =false;
}
if (shapeMovementCount==-shapeMovementAmplitude){
    
  shapeMovementDirection =true;
}


//calculating shrinking behaviour
if (shapeShrinkingDirection==true){
    shapeShrinkingVelocity+=shapeShrinkingAcceleration;
    shapeShrinkingCount++;
  }
  else{
    shapeShrinkingVelocity-=shapeShrinkingAcceleration;
    shapeShrinkingCount--;
  }
if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
  shapeShrinkingDirection =false;
}
if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
  shapeShrinkingDirection =true;
}

//changing angle of a shape
xRotation+=xRotationSpeed;
yRotation+=yRotationSpeed;
zRotation+=zRotationSpeed;

}

 public void display() {

stroke(shapeColor);
noFill();
strokeWeight(2);

pushMatrix();
translate(xShape+shapeMovementVelocity,yShape, zShape);
rotateX(xRotation);
//rotateY(yRotation);
rotateZ(zRotation);
for (int i=0; i<4; i++){
rotateZ(PI/2);
beginShape();
vertex(0,0,0.4f*shapeSize);
vertex(-0.2f*shapeSize,0.2f*shapeSize);
vertex(0,0.8f*shapeSize);
vertex(0.2f*shapeSize,0.2f*shapeSize);
vertex(0,0,0.4f*shapeSize);
vertex(0,0.8f*shapeSize);
endShape();

}
rotateZ(PI/4);
for (int i=0; i<4; i++){
rotateZ(PI/2);
beginShape();
vertex(0,0,0.4f*shapeSize);
vertex(-0.15f*shapeSize,0.15f*shapeSize);
vertex(0,0.6f*shapeSize);
vertex(0.15f*shapeSize,0.15f*shapeSize);
vertex(0,0,0.4f*shapeSize);
vertex(0,0.6f*shapeSize);
endShape();

}
rotateZ(PI/4);
for (int i=0; i<4; i++){
rotateZ(PI/2);
beginShape();
vertex(0,0,-0.4f*shapeSize);
vertex(-0.2f*shapeSize,0.2f*shapeSize);
vertex(0,0.8f*shapeSize);
vertex(0.2f*shapeSize,0.2f*shapeSize);
vertex(0,0,-0.4f*shapeSize);
vertex(0,0.8f*shapeSize);
endShape();

}
rotateZ(PI/4);
for (int i=0; i<4; i++){
rotateZ(PI/2);
beginShape();
vertex(0,0,-0.4f*shapeSize);
vertex(-0.15f*shapeSize,0.15f*shapeSize);
vertex(0,0.6f*shapeSize);
vertex(0.15f*shapeSize,0.15f*shapeSize);
vertex(0,0,-0.4f*shapeSize);
vertex(0,0.6f*shapeSize);
endShape();



}
popMatrix();
}
}

class Engine {
  float x = 0; 
  float y = 0;
  float z = 0;
  float s= 0;
  int c = color(0,0,0);
  
  Engine(float x, float y, float z, int c) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.c = c;
  }
  
  Engine(float x, float y, float z, float s, int c) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.s =s;
    this.c = c;
  }
}

class Craft {

  float s;
  float shapeX; 
  float shapeY = 45; 
  float shapeZ = 370;
  ArrayList<Engine> engines1 = new ArrayList<Engine>();
  ArrayList<Engine> engines2 = new ArrayList<Engine>();
  float amplitude = 10;
  float len = 300;
  float aceleration = 3;
  float velocity = 0;
  float zVelocity = 0.1f;
  float zAmplitude = 30;
  float count = 0;
  float angle = 0;
  boolean direction = true;
  
  Craft(float size) {
    this.s = size;
  }
  
   public void calculating(){
  
      angle += 0.2f;
      shapeX = sin(angle/20)*50;
      
      if(count >= zAmplitude) {
        direction = !direction;
        count = 0;
      }
      if(direction) {
        shapeZ += zVelocity;
       
      } else {
        shapeZ -= zVelocity;
      }
      count +=zVelocity;
  
  }
  
   public void display() {
  
    pushMatrix();
     translate(shapeX, shapeY, shapeZ);
     rotateX(-PI/50);
     rotateZ(-sin(angle/20)/2);
    translate(-shapeX, -shapeY, -shapeZ);
    stroke(color(178,100,100));
    strokeWeight(4);
    noFill();
    pushMatrix();
    //craft
    translate(shapeX, shapeY, shapeZ);
   
    beginShape();
    vertex(-100*s, -50*s, 100*s);
    vertex( 100*s, -50*s, 100*s);
    vertex( 150*s,  50*s, 100*s);
    vertex( -150*s,  50*s, 100*s);
    vertex(-100*s, -50*s, 100*s);

    vertex(0,-25*s,-350*s);
    vertex( 100*s, -50*s, 100*s);
    
    vertex( 150*s,  50*s, 100*s);
    vertex(0,-25*s,-350*s);
    vertex( -150*s,  50*s, 100*s);
    
    
    endShape();
    
    beginShape();
    vertex(0, -50*s, 100*s);
    vertex( 0*s, -200*s, 200*s);
    vertex( 0*s,  -30*s, -100*s);
    vertex( 0,  -25*s, -350*s);
   
    
    endShape();
    popMatrix();
    
    //engine 1
    stroke(color(322,100,100));
    strokeWeight(2);
    ArrayList<Engine> found = new ArrayList<Engine>();
    for(Engine engine: engines1) {
      engine.z += aceleration;
      pushMatrix();
      translate(engine.x, engine.y, engine.z);
      
      circle(0,0, 40*s);
      popMatrix();
      if(engine.z - shapeZ - 100*s > len ) {
        found.add(engine);
      }
    }
    engines1.removeAll(found);
    found.clear();
    //engine 2
    for(Engine engine: engines2) {
      engine.z += aceleration;
      pushMatrix();
      translate(engine.x, engine.y, engine.z);
      circle(0,0, 40*s);
      popMatrix();
      if(engine.z - shapeZ - 100*s > len) {
        found.add(engine);
      }
    }
    engines2.removeAll(found);
    
    velocity += aceleration;
    if(velocity > amplitude) {
        angle += 0.09f;
        engines1.add(new Engine(shapeX + 80*s, shapeY, shapeZ + 100*s, 0));
        engines2.add(new Engine(shapeX -80*s,  shapeY, shapeZ + 100*s, 0));
        velocity = 0;
    }
     
     popMatrix();
  
  }


}
class Cube implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
  //variables for movement
  boolean shapeMovementDirection =true;
  int shapeMovementCount;
  int shapeMovementAmplitude = 60;
  float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
  float shapeMovementAcceleration = 0.1f;
  //variables for shrinking
  boolean shapeShrinkingDirection =true;
  int shapeShrinkingCount;
  int shapeShrinkingAmplitude = 200;
  float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
  float shapeShrinkingAcceleration = 0.1f;

  float shapeSize =100;
  int shapeColor = color(200, 100,58);
  float xRotation;
  float yRotation;
  float zRotation;
  float xRotationSpeed=0.01f;
  float yRotationSpeed=0.01f; 
  float zRotationSpeed = 0;

  Cube () {
  
  }
  
 
   public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude,float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
    this.xShape = xShape;
    this.yShape = yShape;
    this.zShape = zShape;
    this.shapeMovementAmplitude = shapeMovementAmplitude;
    this.shapeMovementAcceleration = shapeMovementAcceleration;
    this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
    this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
    this.shapeSize = shapeSize;
    this.shapeColor = shapeColor;
    this.xRotation = xRotation;
    this.yRotation = yRotation;
    this.zRotation = zRotation;
    this.xRotationSpeed =  xRotationSpeed;
    this.yRotationSpeed =  yRotationSpeed;
    this.zRotationSpeed =  zRotationSpeed;

}
  
   public void calculating() {
    if (shapeMovementDirection==true){
      shapeMovementVelocity+=0.25f;
      shapeMovementCount++;
    }
    else{
      shapeMovementVelocity-=0.25f;
      shapeMovementCount--;
    }
    if (shapeMovementCount==shapeMovementAmplitude){
      shapeMovementDirection =false;
    }
    if (shapeMovementCount==-shapeMovementAmplitude){
      shapeMovementDirection =true;
    }

    xRotation+=xRotationSpeed;
    yRotation+=yRotationSpeed;;
    zRotation += zRotationSpeed;
  }

   public void display() {
    noFill();
    stroke(shapeColor);
    strokeWeight(4);
    pushMatrix();
    translate(xShape+shapeMovementVelocity, yShape, zShape);
    rotateZ(zRotation);
    rotateX(xRotation);
    rotateY(yRotation);
    beginShape(LINES);

      vertex(-shapeSize, -shapeSize, shapeSize);
      vertex(shapeSize, -shapeSize,shapeSize);
      
      vertex(shapeSize,shapeSize,shapeSize);
      vertex(-shapeSize, shapeSize, shapeSize);
      
      vertex(-shapeSize, shapeSize,-shapeSize);
      vertex(shapeSize,shapeSize,-shapeSize);
      
      vertex(shapeSize, -shapeSize, -shapeSize);
      vertex(-shapeSize, -shapeSize, -shapeSize);
      
      vertex(-shapeSize,shapeSize,shapeSize);
      vertex(-shapeSize,-shapeSize,shapeSize);
      
      vertex (shapeSize,shapeSize,shapeSize);
      vertex(shapeSize,-shapeSize,shapeSize);
      
      vertex(-shapeSize,shapeSize,-shapeSize);
      vertex(-shapeSize,-shapeSize,-shapeSize);
      
      vertex (shapeSize,shapeSize,-shapeSize);
      vertex(shapeSize,-shapeSize,-shapeSize);
      
      vertex(-shapeSize,shapeSize,shapeSize);
      vertex(-shapeSize,shapeSize,-shapeSize);
      
      vertex(shapeSize,shapeSize,shapeSize);
      vertex(shapeSize,shapeSize,-shapeSize);
      
      vertex(-shapeSize,-shapeSize,shapeSize);
      vertex(-shapeSize,-shapeSize,-shapeSize);
      
      vertex(shapeSize,-shapeSize,shapeSize);
      vertex(shapeSize,-shapeSize,-shapeSize);

    endShape();
    popMatrix();
  }
}
class Heart implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
  //variables for movement
  boolean shapeMovementDirection =true;
  int shapeMovementCount;
  int shapeMovementAmplitude = 60;
  float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
  float shapeMovementAcceleration = 0.1f;
  //variables for shrinking
  boolean shapeShrinkingDirection =true;
  int shapeShrinkingCount;
  int shapeShrinkingAmplitude = 200;
  float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
  float shapeShrinkingAcceleration = 0.1f;

  float shapeSize =10;
  int shapeColor = color(188, 70,165);
  float xRotation;
  float yRotation;
  float zRotation;
  float xRotationSpeed = 0;
  float yRotationSpeed = 0.0008f; 
  float zRotationSpeed = 0.0002f;

//сюда передаём значения особых переменных
Heart() {

}

//общие переменные
 public void setuping(float xShape, float yShape, float zShape,int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude, float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
  this.xShape = xShape;
  this.yShape = yShape;
  this.zShape = zShape;
  this.shapeMovementAmplitude = shapeMovementAmplitude;
  this.shapeMovementAcceleration = shapeMovementAcceleration;
  this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
  this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
  this.shapeSize = shapeSize;
  this.shapeColor = shapeColor;
  this.xRotation = xRotation;
  this.yRotation = yRotation;
  this.zRotation = zRotation;
  this.xRotationSpeed =  xRotationSpeed;
  this.yRotationSpeed =  yRotationSpeed;
  this.zRotationSpeed =  zRotationSpeed;

}


 public void calculating() {
  //calculating movement behaviour
if (shapeMovementDirection==true){
    shapeMovementVelocity+=shapeMovementAcceleration;
    shapeMovementCount++;
  }
  else{
    shapeMovementVelocity-=shapeMovementAcceleration;
    shapeMovementCount--;
  }
if (shapeMovementCount==shapeMovementAmplitude){
    
  shapeMovementDirection =false;
}
if (shapeMovementCount==-shapeMovementAmplitude){
    
  shapeMovementDirection =true;
}


//calculating shrinking behaviour
if (shapeShrinkingDirection==true){
    shapeShrinkingVelocity+=shapeShrinkingAcceleration;
    shapeShrinkingCount++;
  }
  else{
    shapeShrinkingVelocity-=shapeShrinkingAcceleration;
    shapeShrinkingCount--;
  }
if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
  shapeShrinkingDirection =false;
}
if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
  shapeShrinkingDirection =true;
}

//changing angle of a shape
xRotation+=xRotationSpeed;
yRotation+=yRotationSpeed;
zRotation+=zRotationSpeed;

}

 public void display() {

stroke(shapeColor);
noFill();
strokeWeight(4);

pushMatrix();
translate(xShape+shapeMovementVelocity,yShape, zShape);
rotateX(xRotation);
rotateY(yRotation);
rotateZ(zRotation);


beginShape();

for (float a=0; a<TWO_PI;a+=0.01f){
    
  float x = shapeSize/10 *16*pow(sin(a),3);
  float y = -shapeSize/10 *(13 *cos(a)- 5*cos(2*a)- 2*cos(3*a) - cos(4*a));
  vertex(x+shapeShrinkingVelocity,y+shapeShrinkingVelocity);
  
}
endShape();
popMatrix();
}
}
class Octahedron implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
  //variables for movement
  boolean shapeMovementDirection =true;
  int shapeMovementCount;
  int shapeMovementAmplitude = 60;
  float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
  float shapeMovementAcceleration = 0.1f;
  //variables for shrinking
  boolean shapeShrinkingDirection =true;
  int shapeShrinkingCount;
  int shapeShrinkingAmplitude = 200;
  float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
  float shapeShrinkingAcceleration = 0.1f;

  float shapeSize =100;
  int shapeColor = color(200, 100,58);
  float xRotation;
  float yRotation;
  float zRotation;
  float xRotationSpeed=0.01f;
  float yRotationSpeed=0.01f; 
  float zRotationSpeed = 0;

Octahedron() {


}

 public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude,float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
  this.xShape = xShape;
  this.yShape = yShape;
  this.zShape = zShape;
  this.shapeMovementAmplitude = shapeMovementAmplitude;
  this.shapeMovementAcceleration = shapeMovementAcceleration;
  this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
  this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
  this.shapeSize = shapeSize;
  this.shapeColor = shapeColor;
  this.xRotation = xRotation;
  this.yRotation = yRotation;
  this.zRotation = zRotation;
  this.xRotationSpeed =  xRotationSpeed;
  this.yRotationSpeed =  yRotationSpeed;
  this.zRotationSpeed =  zRotationSpeed;

}

 public void calculating() {
  //calculating movement behaviour
if (shapeMovementDirection==true){
    shapeMovementVelocity+=shapeMovementAcceleration;
    shapeMovementCount++;
  }
  else{
    shapeMovementVelocity-=shapeMovementAcceleration;
    shapeMovementCount--;
  }
if (shapeMovementCount==shapeMovementAmplitude){
    
  shapeMovementDirection =false;
}
if (shapeMovementCount==-shapeMovementAmplitude){
    
  shapeMovementDirection =true;
}


//calculating shrinking behaviour
if (shapeShrinkingDirection==true){
    shapeShrinkingVelocity+=shapeShrinkingAcceleration;
    shapeShrinkingCount++;
  }
  else{
    shapeShrinkingVelocity-=shapeShrinkingAcceleration;
    shapeShrinkingCount--;
  }
if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
  shapeShrinkingDirection =false;
}
if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
  shapeShrinkingDirection =true;
}

//changing angle of a shape
xRotation+=xRotationSpeed;
yRotation+=yRotationSpeed;
zRotation+=zRotationSpeed;

}


 public void display() {
stroke(shapeColor);
strokeWeight(4);

pushMatrix();
translate(xShape+shapeMovementVelocity,yShape, zShape);
rotateX(xRotation);
rotateY(yRotation);
rotateZ(zRotation);


//actually drawing the shape
beginShape(LINES);

vertex(shapeSize, -shapeSize/sqrt(3),0);
vertex(-shapeSize, -shapeSize/sqrt(3),0);

vertex(-shapeSize, -shapeSize/sqrt(3),0);
vertex(0, 2*shapeSize/sqrt(3), 0);

vertex(shapeSize, -shapeSize/sqrt(3),0);
vertex(0, 2*shapeSize/sqrt(3), 0);

vertex(0,0,3*shapeSize/sqrt(6));
vertex(shapeSize, -shapeSize/sqrt(3),0);

vertex(0,0,3*shapeSize/sqrt(6));
vertex(-shapeSize, -shapeSize/sqrt(3),0);

vertex(0,0,3*shapeSize/sqrt(6));
vertex(0, 2*shapeSize/sqrt(3), 0);
//
vertex(0,0,-3*shapeSize/sqrt(6));
vertex(shapeSize, -shapeSize/sqrt(3),0);

vertex(0,0,-3*shapeSize/sqrt(6));
vertex(-shapeSize, -shapeSize/sqrt(3),0);

vertex(0,0,-3*shapeSize/sqrt(6));
vertex(0, 2*shapeSize/sqrt(3), 0);


endShape();
popMatrix();
}
}
 public void setColors(){
float sky, grad1, grad2;
float h = random(0,190);
float s = random(50,90);
float b = random(50,90);

sky = random(230,270);
if (random(2)>1){
grad1 = random(0, 50);
} else {
grad1 = random(310, 360);
}
if (random(2)>1){
grad2 = random(0, 50);
} else {
grad2 = random(310, 360);
}
colors[0] = sky;
colors[1] = grad1;
colors[2] = grad2;
colors[3] = random(0,180);
colors[4] = random(0,180);;
colors[5] = random(0,180);;
//print("sh");
}
class Square implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
  //variables for movement
  boolean shapeMovementDirection =true;
  int shapeMovementCount;
  int shapeMovementAmplitude = 60;
  float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
  float shapeMovementAcceleration = 0.1f;
  //variables for shrinking
  boolean shapeShrinkingDirection =true;
  int shapeShrinkingCount;
  int shapeShrinkingAmplitude = 200;
  float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
  float shapeShrinkingAcceleration = 0.1f;

  float shapeSize =10;
  int shapeColor = color(188, 70,165);
  float xRotation;
  float yRotation;
  float zRotation;
  float xRotationSpeed = 0;
  float yRotationSpeed = 0.0008f; 
  float zRotationSpeed = 0.0002f;

//сюда передаём значения особых переменных
Square() {

}

//общие переменные
 public void setuping(float xShape, float yShape, float zShape,int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude, float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
  this.xShape = xShape;
  this.yShape = yShape;
  this.zShape = zShape;
  this.shapeMovementAmplitude = shapeMovementAmplitude;
  this.shapeMovementAcceleration = shapeMovementAcceleration;
  this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
  this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
  this.shapeSize = shapeSize;
  this.shapeColor = shapeColor;
  this.xRotation = xRotation;
  this.yRotation = yRotation;
  this.zRotation = zRotation;
  this.xRotationSpeed =  xRotationSpeed;
  this.yRotationSpeed =  yRotationSpeed;
  this.zRotationSpeed =  zRotationSpeed;

}


 public void calculating() {
  //calculating movement behaviour
if (shapeMovementDirection==true){
    shapeMovementVelocity+=shapeMovementAcceleration;
    shapeMovementCount++;
  }
  else{
    shapeMovementVelocity-=shapeMovementAcceleration;
    shapeMovementCount--;
  }
if (shapeMovementCount==shapeMovementAmplitude){
    
  shapeMovementDirection =false;
}
if (shapeMovementCount==-shapeMovementAmplitude){
    
  shapeMovementDirection =true;
}


//calculating shrinking behaviour
if (shapeShrinkingDirection==true){
    shapeShrinkingVelocity+=shapeShrinkingAcceleration;
    shapeShrinkingCount++;
  }
  else{
    shapeShrinkingVelocity-=shapeShrinkingAcceleration;
    shapeShrinkingCount--;
  }
if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
  shapeShrinkingDirection =false;
}
if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
  shapeShrinkingDirection =true;
}

//changing angle of a shape
xRotation+=xRotationSpeed;
yRotation+=yRotationSpeed;
zRotation+=zRotationSpeed;

}

 public void display() {

stroke(shapeColor);
noFill();
strokeWeight(4);

pushMatrix();
translate(xShape+shapeMovementVelocity,yShape, zShape);
rotateX(xRotation);
rotateY(yRotation);
rotateZ(zRotation);


beginShape();
vertex(shapeSize+shapeShrinkingVelocity,shapeSize+shapeShrinkingVelocity);
vertex(-shapeSize+shapeShrinkingVelocity,shapeSize+shapeShrinkingVelocity);
vertex(-shapeSize+shapeShrinkingVelocity,-shapeSize+shapeShrinkingVelocity);
vertex(shapeSize+shapeShrinkingVelocity,-shapeSize+shapeShrinkingVelocity);
vertex(shapeSize+shapeShrinkingVelocity,shapeSize+shapeShrinkingVelocity);



  

endShape();
popMatrix();
}
}
class Sun {
  float radius =170;
  float angle = PI/180;
  float sunVelocity =0;
  float centerX = 0;
  float centerY =0;
  int count = 0;
  int sunAmplitude = 200;
  boolean direction;
  int from = color(0, 0, 0);
  int to = color(255, 255, 255);

  Sun() {
  
  }
  
  Sun(int from, int to) {
    this.from = from;
    this.to = to;
  }
  
   public void calculating() {
    if (direction==true){
      sunVelocity+=0.1f;
      count++;
    }
    else{
      sunVelocity-=0.1f;
      count--;
    }
    if (count==sunAmplitude){
     direction =false;
    }
    if (count==-sunAmplitude){
      direction =true;
    }  
   }
   
    public void display() {
    noFill();
    stroke(1.8f* map(8, 0, 17, 0,255),0.6f *map(8, 0, 17, 0,255),1.1f*map(8, 0, 17, 0,255));
    circle(centerX, centerY+sunVelocity,  radius*2);
    for (int i =0; i<18; i=i+1) {
      angle+=PI/18;
      float lineLen = 2*radius*sin(angle/2);
      float lineHeight = sqrt(radius*radius-(lineLen/2)*(lineLen/2));
      strokeWeight(1);
      stroke(1.8f* map(i, 0, 17, 0,255),0.6f *map(i, 0, 17, 0,255),1.1f*map(i, 0, 17, 0,255));
      line(-lineLen/2, lineHeight+sunVelocity, lineLen/2, lineHeight+sunVelocity);
      line(-lineLen/2, -lineHeight+sunVelocity, lineLen/2, -lineHeight+sunVelocity);
    }
   }
}
class SuperShape implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
//variables for movement
boolean shapeMovementDirection =true;
int shapeMovementCount;
int shapeMovementAmplitude = 60;
float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
float shapeMovementAcceleration = 0.1f;
//variables for shrinking
boolean shapeShrinkingDirection =true;
int shapeShrinkingCount;
int shapeShrinkingAmplitude = 200;
float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
float shapeShrinkingAcceleration = 0.1f;

float shapeSize =200;
int  shapeColor = color(200, 100,58);
float xRotation;
float yRotation;
float zRotation;
float xRotationSpeed = 0;
float yRotationSpeed = 0.0008f; 
float zRotationSpeed = 0.0002f;
//supershape variables
float n1 = 0.3f;
float n2 = 1.7f;
float n3 = 1.7f;

float m = 5;
float a = 1;
float b = 1;
float osc = 0;

SuperShape(){}

SuperShape(float n1, float n2, float n3, float m, float a, float b, float osc){
  this.n1 = n1;
  this.n2 = n2;
  this.n3 = n3;
  this.m = m;
  this.a = a;
  this.b = b;
  this.osc = osc;
}

 public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude,float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
  this.xShape = xShape;
  this.yShape = yShape;
  this.zShape = zShape;
  this.shapeMovementAmplitude = shapeMovementAmplitude;
  this.shapeMovementAcceleration = shapeMovementAcceleration;
  this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
  this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
  this.shapeSize = shapeSize;
  this.shapeColor = shapeColor;
  this.xRotation = xRotation;
  this.yRotation = yRotation;
  this.zRotation = zRotation;
  this.xRotationSpeed =  xRotationSpeed;
  this.yRotationSpeed =  yRotationSpeed;
  this.zRotationSpeed =  zRotationSpeed;
}
  
 public void calculating() {
if (shapeMovementDirection==true){
    shapeMovementVelocity+=shapeMovementAcceleration;
    shapeMovementCount++;
  }
  else{
    shapeMovementVelocity-=shapeMovementAcceleration;
    shapeMovementCount--;
  }
if (shapeMovementCount==shapeMovementAmplitude){
    
  shapeMovementDirection =false;
}
if (shapeMovementCount==-shapeMovementAmplitude){
    
  shapeMovementDirection =true;
}


//calculating shrinking behaviour
if (shapeShrinkingDirection==true){
    shapeShrinkingVelocity+=shapeShrinkingAcceleration;
    shapeShrinkingCount++;
  }
  else{
    shapeShrinkingVelocity-=shapeShrinkingAcceleration;
    shapeShrinkingCount--;
  }
if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
  shapeShrinkingDirection =false;
}
if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
  shapeShrinkingDirection =true;
}

//changing angle of a shape
xRotation+=xRotationSpeed;
yRotation+=yRotationSpeed;
zRotation+=zRotationSpeed;

n1 = map((float) Math.sin(osc), -1.0f, 1.0f, 0.02f, 0.5f);
osc += 0.02f;
}
 public void display(){
  
stroke(shapeColor);
strokeWeight(4);
noFill();
 
pushMatrix();
translate(xShape,yShape, zShape); 
rotateX(xRotation);
rotateY(yRotation);
rotateZ(zRotation);
  
  
  
beginShape();
  
   for (float angle = 0; angle < TWO_PI; angle += TWO_PI/500) {
    float r = super_shape(angle);
    float x = shapeSize * r * cos(angle);
    float y = shapeSize * r * sin(angle);
    float z = 0;

    vertex(x+shapeMovementVelocity, y, z);
  }
endShape();
popMatrix();
}

 public float super_shape(float theta){
  float part1 = (1 / a) * cos(theta * m / 4);
  part1 = abs(part1);
  part1 = pow(part1, n2);

  float part2 = (1 / b) * sin(theta * m / 4);
  part2 = abs(part2);
  part2 = pow(part2, n3);

  float part3 = pow(part1 + part2, 1 / n1);

  if (part3 == 0) {
    return 0;
  }

  return (1 / part3);
}
}
class SuperShape2 implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
//variables for movement
boolean shapeMovementDirection =true;
int shapeMovementCount;
int shapeMovementAmplitude = 60;
float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
float shapeMovementAcceleration = 0.1f;
//variables for shrinking
boolean shapeShrinkingDirection =true;
int shapeShrinkingCount;
int shapeShrinkingAmplitude = 200;
float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
float shapeShrinkingAcceleration = 0.1f;

float shapeSize =200;
int  shapeColor = color(200, 100,58);
float xRotation;
float yRotation;
float zRotation;
float xRotationSpeed = 0;
float yRotationSpeed = 0.0008f; 
float zRotationSpeed = 0.0002f;
//supershape variables
float n1 = 36;
float n2 = 4.74f;
float n3 = 4.0f;

float m = 20;
float a = 0.1f;
float b = 0.61f;
float osc = 0;

SuperShape2(){}

SuperShape2(float n1, float n2, float n3, float m, float a, float b, float osc){
  this.n1 = n1;
  this.n2 = n2;
  this.n3 = n3;
  this.m = m;
  this.a = a;
  this.b = b;
  this.osc = osc;
}

 public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude,float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
  this.xShape = xShape;
  this.yShape = yShape;
  this.zShape = zShape;
  this.shapeMovementAmplitude = shapeMovementAmplitude;
  this.shapeMovementAcceleration = shapeMovementAcceleration;
  this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
  this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
  this.shapeSize = shapeSize;
  this.shapeColor = shapeColor;
  this.xRotation = xRotation;
  this.yRotation = yRotation;
  this.zRotation = zRotation;
  this.xRotationSpeed =  xRotationSpeed;
  this.yRotationSpeed =  yRotationSpeed;
  this.zRotationSpeed =  zRotationSpeed;
}
  
 public void calculating() {
if (shapeMovementDirection==true){
    shapeMovementVelocity+=shapeMovementAcceleration;
    shapeMovementCount++;
  }
  else{
    shapeMovementVelocity-=shapeMovementAcceleration;
    shapeMovementCount--;
  }
if (shapeMovementCount==shapeMovementAmplitude){
    
  shapeMovementDirection =false;
}
if (shapeMovementCount==-shapeMovementAmplitude){
    
  shapeMovementDirection =true;
}


//calculating shrinking behaviour
if (shapeShrinkingDirection==true){
    shapeShrinkingVelocity+=shapeShrinkingAcceleration;
    shapeShrinkingCount++;
  }
  else{
    shapeShrinkingVelocity-=shapeShrinkingAcceleration;
    shapeShrinkingCount--;
  }
if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
  shapeShrinkingDirection =false;
}
if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
  shapeShrinkingDirection =true;
}

//changing angle of a shape
xRotation+=xRotationSpeed;
yRotation+=yRotationSpeed;
zRotation+=zRotationSpeed;

n2 = map((float) Math.sin(osc), -1.0f, 1.0f, 2, 8);
osc += 0.02f;
}
 public void display(){
  
stroke(shapeColor);
strokeWeight(4);
noFill();
 
pushMatrix();
translate(xShape,yShape, zShape); 
rotateX(xRotation);
rotateY(yRotation);
rotateZ(zRotation);
  
  
  
beginShape();
  
   for (float angle = 0; angle < TWO_PI; angle += TWO_PI/500) {
    float r = super_shape(angle);
    float x = shapeSize * r * cos(angle);
    float y = shapeSize * r * sin(angle);
    float z = 0;

    vertex(x+shapeMovementVelocity, y, z);
  }
endShape();
popMatrix();
}

 public float super_shape(float theta){
  float part1 = (1 / a) * cos(theta * m / 4);
  part1 = abs(part1);
  part1 = pow(part1, n2);

  float part2 = (1 / b) * sin(theta * m / 4);
  part2 = abs(part2);
  part2 = pow(part2, n3);

  float part3 = pow(part1 + part2, 1 / n1);

  if (part3 == 0) {
    return 0;
  }

  return (1 / part3);
}
}
class SuperShape3 implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
//variables for movement
boolean shapeMovementDirection =true;
int shapeMovementCount;
int shapeMovementAmplitude = 60;
float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
float shapeMovementAcceleration = 0.1f;
//variables for shrinking
boolean shapeShrinkingDirection =true;
int shapeShrinkingCount;
int shapeShrinkingAmplitude = 200;
float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
float shapeShrinkingAcceleration = 0.1f;

float shapeSize =200;
int  shapeColor = color(200, 100,58);
float xRotation;
float yRotation;
float zRotation;
float xRotationSpeed = 0;
float yRotationSpeed = 0.0008f; 
float zRotationSpeed = 0.0002f;
//supershape variables
float n1 = 100;
float n2 = 15.25f;
float n3 = -26.0f;

float m = 10;
float a = 0.29f;
float b = 0.34f;
float osc = 0;

SuperShape3(){}

SuperShape3(float n1, float n2, float n3, float m, float a, float b, float osc){
  this.n1 = n1;
  this.n2 = n2;
  this.n3 = n3;
  this.m = m;
  this.a = a;
  this.b = b;
  this.osc = osc;
}

 public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude,float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
  this.xShape = xShape;
  this.yShape = yShape;
  this.zShape = zShape;
  this.shapeMovementAmplitude = shapeMovementAmplitude;
  this.shapeMovementAcceleration = shapeMovementAcceleration;
  this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
  this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
  this.shapeSize = shapeSize;
  this.shapeColor = shapeColor;
  this.xRotation = xRotation;
  this.yRotation = yRotation;
  this.zRotation = zRotation;
  this.xRotationSpeed =  xRotationSpeed;
  this.yRotationSpeed =  yRotationSpeed;
  this.zRotationSpeed =  zRotationSpeed;
}
  
 public void calculating() {
if (shapeMovementDirection==true){
    shapeMovementVelocity+=shapeMovementAcceleration;
    shapeMovementCount++;
  }
  else{
    shapeMovementVelocity-=shapeMovementAcceleration;
    shapeMovementCount--;
  }
if (shapeMovementCount==shapeMovementAmplitude){
    
  shapeMovementDirection =false;
}
if (shapeMovementCount==-shapeMovementAmplitude){
    
  shapeMovementDirection =true;
}


//calculating shrinking behaviour
if (shapeShrinkingDirection==true){
    shapeShrinkingVelocity+=shapeShrinkingAcceleration;
    shapeShrinkingCount++;
  }
  else{
    shapeShrinkingVelocity-=shapeShrinkingAcceleration;
    shapeShrinkingCount--;
  }
if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
  shapeShrinkingDirection =false;
}
if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
  shapeShrinkingDirection =true;
}

//changing angle of a shape
xRotation+=xRotationSpeed;
yRotation+=yRotationSpeed;
zRotation+=zRotationSpeed;


osc += 0.02f;
}
 public void display(){
  
stroke(shapeColor);
strokeWeight(4);
noFill();
 
pushMatrix();
translate(xShape,yShape, zShape); 
rotateX(xRotation);
rotateY(yRotation);
rotateZ(zRotation);
  
  
  
beginShape();
  
   for (float angle = 0; angle < TWO_PI; angle += TWO_PI/500) {
    float r = super_shape(angle);
    float x = shapeSize * r * cos(angle);
    float y = shapeSize * r * sin(angle);
    float z = 0;

    vertex(x+shapeMovementVelocity, y, z);
  }
endShape();
popMatrix();
}

 public float super_shape(float theta){
  float part1 = (1 / a) * cos(theta * m / 4);
  part1 = abs(part1);
  part1 = pow(part1, n2);

  float part2 = (1 / b) * sin(theta * m / 4);
  part2 = abs(part2);
  part2 = pow(part2, n3);

  float part3 = pow(part1 + part2, 1 / n1);

  if (part3 == 0) {
    return 0;
  }

  return (1 / part3);
}
}
class Terrain {
  int cols;
  int rows;
  int scl = 20;
  int w = 1000;
  int h = 1000;
  float flying = 0;
  float terrainVelocity = 0.045f;
  float[][] terrain;
  int terrainAmplitude = 40;
  int strokeColor = color (255);
  int terrainColor = color (0);
  
  Terrain() {
    cols = w/scl;
    rows = h/scl;
    terrain = new float[cols][rows];
  }
  
  Terrain(int strokeColor, int terrainColor) {
    this.strokeColor = strokeColor;
    this.terrainColor = terrainColor;
    cols = w/scl;
    rows = h/scl;
    terrain = new float[cols][rows];
  }
  
   public void calculating() {
    flying-=terrainVelocity;
    float yoff = flying;
    for (int y = 0; y<rows; y++){
      float xoff = 0;
      for (int x = 0;  x<cols; x++){
        terrain[x][y] = map(noise(xoff,yoff), 0 ,1, -terrainAmplitude, terrainAmplitude);
        xoff+=0.3f;
       }
      yoff+=0.3f;
    }
  }


   public void display() {
    stroke(strokeColor);
    fill(terrainColor);
   
    pushMatrix();
    rotateX(PI/2.3f);
    translate(-w/2,-h/2+500);
    for (int y = 0; y<rows-1; y++){
      beginShape(TRIANGLE_STRIP);
      for (int x = 0;  x<cols; x++){
        vertex(x*scl, y*scl, terrain[x][y]);
        vertex(x*scl, (y+1)*scl, terrain[x][y+1]);
      }
      endShape();
    }
    popMatrix();
  }
}
class Tetrahedron implements GrafOBJ{
  float xShape;
  float yShape;
  float zShape;
  //variables for movement
  boolean shapeMovementDirection =true;
  int shapeMovementCount;
  int shapeMovementAmplitude = 60;
  float shapeMovementVelocity; //add this to all x or y or z vertex coordinates, to get a movement effect
  float shapeMovementAcceleration = 0.1f;
  //variables for shrinking
  boolean shapeShrinkingDirection =true;
  int shapeShrinkingCount;
  int shapeShrinkingAmplitude = 200;
  float shapeShrinkingVelocity; //add this to all x or y or z vertex coordinates, to get a shrinking(scaling) effect
  float shapeShrinkingAcceleration = 0.1f;

  float shapeSize =100;
  int shapeColor = color(200, 100,58);
  float xRotation;
  float yRotation;
  float zRotation;
  float xRotationSpeed = 0;
  float yRotationSpeed = 0.0008f; 
  float zRotationSpeed = 0.0002f;


  Tetrahedron() {
   
   
  }
  
   public void setuping(float xShape, float yShape, float zShape, int shapeMovementAmplitude, float shapeMovementAcceleration, int shapeShrinkingAmplitude, float shapeShrinkingAcceleration, float shapeSize, int shapeColor, float xRotation, float yRotation, float zRotation, float xRotationSpeed, float yRotationSpeed, float zRotationSpeed) {
    this.xShape = xShape;
    this.yShape = yShape;
    this.zShape = zShape;
    this.shapeMovementAmplitude = shapeMovementAmplitude;
    this.shapeMovementAcceleration = shapeMovementAcceleration;
    this.shapeShrinkingAmplitude = shapeShrinkingAmplitude;
    this.shapeShrinkingAcceleration = shapeShrinkingAcceleration;
    this.shapeSize = shapeSize;
    this.shapeColor = shapeColor;
    this.xRotation = xRotation;
    this.yRotation = yRotation;
    this.zRotation = zRotation;
    this.xRotationSpeed =  xRotationSpeed;
    this.yRotationSpeed =  yRotationSpeed;
    this.zRotationSpeed =  zRotationSpeed;

}
  
   public void calculating() {
    //calculating movement behaviour
    if (shapeMovementDirection==true){
      shapeMovementVelocity+=shapeMovementAcceleration;
      shapeMovementCount++;
    }
    else{
      shapeMovementVelocity-=shapeMovementAcceleration;
      shapeMovementCount--;
    }
    if (shapeMovementCount==shapeMovementAmplitude){
    
      shapeMovementDirection =false;
    }
    if (shapeMovementCount==-shapeMovementAmplitude){
    
      shapeMovementDirection =true;
    }


    //calculating shrinking behaviour
    if (shapeShrinkingDirection==true){
      shapeShrinkingVelocity+=shapeShrinkingAcceleration;
      shapeShrinkingCount++;
    }
    else{
      shapeShrinkingVelocity-=shapeShrinkingAcceleration;
      shapeShrinkingCount--;
    }
    if (shapeShrinkingCount==shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =false;
    }
    if (shapeShrinkingCount==-shapeShrinkingAmplitude){
    
      shapeShrinkingDirection =true;
    }

    //changing angle of a shape
    xRotation+=xRotationSpeed;
    yRotation+=yRotationSpeed;
    zRotation+=zRotationSpeed;
  }
  
   public void display(){
    stroke(shapeColor);
    strokeWeight(4);
    
    pushMatrix();
    translate(xShape+shapeMovementVelocity,yShape, zShape);
    rotateX(xRotation);
    rotateY(yRotation);
    rotateZ(zRotation);


    //actually drawing the shape
    beginShape(LINES);

    vertex(shapeSize, -shapeSize/sqrt(3),-shapeSize/sqrt(6));
    vertex(-shapeSize, -shapeSize/sqrt(3),-shapeSize/sqrt(6));

    vertex(-shapeSize, -shapeSize/sqrt(3),-shapeSize/sqrt(6));
    vertex(0, 2*shapeSize/sqrt(3), -shapeSize/sqrt(6));

    vertex(shapeSize, -shapeSize/sqrt(3),-shapeSize/sqrt(6));
    vertex(0, 2*shapeSize/sqrt(3), -shapeSize/sqrt(6));

    vertex(0,0,3*shapeSize/sqrt(6));
    vertex(shapeSize, -shapeSize/sqrt(3),-shapeSize/sqrt(6));

    vertex(0,0,3*shapeSize/sqrt(6));
    vertex(-shapeSize, -shapeSize/sqrt(3),-shapeSize/sqrt(6));

    vertex(0,0,3*shapeSize/sqrt(6));
    vertex(0, 2*shapeSize/sqrt(3), -shapeSize/sqrt(6));



    endShape();
    popMatrix();
  }
}
class UFO {
  float s; //size of ufo
  float shapeX; 
  float shapeY = 30; 
  float shapeZ = 420;
  ArrayList<Engine> engines1 = new ArrayList<Engine>();
  float amplitude = 2; //length between two circles of engine
  float len = 200; // len of engine trace
  float aceleration = 3; // trace speed
  float radius = 80;
  float velocity = 0;
  float yVelocity = 0;
  float yAcceleration = 0.02f;
  float zVelocity = 0.1f;
  float zAmplitude = 30;
  float count = 0;
  float angle = 0;
  boolean direction = true;
  
  

UFO(float s){
  this.s = s;

}

 public void calculating() {
      angle += 0.2f;
      shapeX = sin(angle/20)*50;
      
      if(count >= zAmplitude) {
        direction = !direction;
        count = 0;
      }
      if(direction) {
        shapeZ += zVelocity;
       
      } else {
        shapeZ -= zVelocity;
      }
      count +=zVelocity;
      yVelocity += yAcceleration;
}

 public void display(){

  strokeWeight(2);
stroke(colors[3],100,100);
noFill();

pushMatrix();
 translate(shapeX, shapeY, shapeZ);
     rotateX(-PI/50);
     rotateZ(-sin(angle/20)/2);
    translate(-shapeX, -shapeY, -shapeZ);
    
    pushMatrix();
     translate(shapeX, shapeY, shapeZ);
     rotateX(PI / 2);
     rotateZ(yVelocity);
//нижние линии
beginShape(LINES);
  
   for (float dangle = 0; dangle < TWO_PI; dangle += TWO_PI/24) {
    float r = 200;
    float x =  r * cos(dangle);
    float y = r * sin(dangle);
    float z = 0;
    
    vertex(x*s, y*s, z*s);
    vertex(0, 0, -75*s);
  }
endShape();

// основной круг
beginShape();
  
   for (float dangle = 0; dangle < TWO_PI; dangle += TWO_PI/500) {
    float r = 200;
    float x =  r * cos(dangle);
    float y = r * sin(dangle);
    float z = 0;
    
     vertex(x*s, y*s, z*s);
    
  }
endShape();

//маленький круг внутри
beginShape();
  
   for (float dangle = 0; dangle < TWO_PI; dangle += TWO_PI/500) {
    float r = 100;
    float x =  r * cos(dangle);
    float y = r * sin(dangle);
    float z = 40;
    
     vertex(x*s, y*s, z*s);
    
  }
endShape();
//линии к маленькому кругу
beginShape(LINES);
  
   for (float dangle = 0; dangle < TWO_PI; dangle += TWO_PI/24) {
    float r = 200;
    float x =  r * cos(dangle);
    float y = r * sin(dangle);
    float z = 0;
    
     vertex(x*s, y*s, z*s);
    vertex(x/2*s, y/2*s, 40*s);
  }
endShape();

strokeWeight(3.5f);
beginShape();
  
   for (float dangle = 0; dangle < PI; dangle += PI/500) {
    float r = 100;
    float x =  r * cos(dangle);
    float y = 0;
    float z = 40 + r * sin(dangle);
    
     vertex(x*s, y*s, z*s);
    
  }
endShape();



beginShape();
   rotateZ(PI/4);
   for (float dangle = 0; dangle < PI; dangle += PI/500) {
    float r = 100;
    float x =  0;
    float y = r * cos(dangle);
    float z = 40 + r * sin(dangle);
    
     vertex(x*s, y*s, z*s);
    
  }
endShape();

beginShape();
   rotateZ(PI/4);
   for (float dangle = 0; dangle < PI; dangle += PI/500) {
    float r = 100;
    float x =  0;
    float y = r * cos(dangle);
    float z = 40 + r * sin(dangle);
    
     vertex(x*s, y*s, z*s);
    
  }
endShape();

beginShape();
   rotateZ(PI/4);
   for (float dangle = 0; dangle < PI; dangle += PI/500) {
    float r = 100;
    float x =  0;
    float y = r * cos(dangle);
    float z = 40 + r * sin(dangle);
    
     vertex(x*s, y*s, z*s);
    
  }
endShape();

beginShape();
   rotateZ(PI/4);
   for (float dangle = 0; dangle < PI; dangle += PI/500) {
    float r = 100;
    float x =  0;
    float y = r * cos(dangle);
    float z = 40 + r * sin(dangle);
    
     vertex(x*s, y*s, z*s);
    
  }
endShape();
popMatrix();

//engine 1
   
    strokeWeight(3);
    ArrayList<Engine> found = new ArrayList<Engine>();
    for(Engine engine: engines1) {
      engine.z += aceleration;
      pushMatrix();
      beginShape(LINES);
      stroke(engine.c, 100 - 100*(engine.z - shapeZ - 100*s)/len);
      translate(engine.x, engine.y, engine.z);
      vertex(0,0,0);
      vertex(0,0,engine.s);
      endShape();
      popMatrix();
      if(engine.z - shapeZ - 100*s > len ) {
        found.add(engine);
      }
    }
    engines1.removeAll(found);
    found.clear();
    
    velocity += aceleration;
    if(velocity > amplitude) {
        angle += 0.09f;
        engines1.add(new Engine(shapeX+2*random(-radius*s, radius*s), shapeY+random(-radius*s, radius*s)/3, shapeZ + 100*s, random(2,15), color(random(350), 100,100)));
        //engines1.add(new Engine(shapeX+2*random(-radius, radius), shapeY+random(-radius, radius)/3, shapeZ + 100*s, random(2,15), color(random(350), 100,100)));
        velocity = 0;
    }
popMatrix();
}
}


  public void settings() { size(960, 720, P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "scenery" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
